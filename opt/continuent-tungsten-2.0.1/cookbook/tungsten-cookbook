#!/usr/bin/perl
use strict;
use warnings;
use File::Basename;
use Data::Dumper;
use English '-no_match_vars';
use Cwd qw/getcwd abs_path/;
## TODO
#
#
#  make T-C able to read the topology from deploy.cfg or tungsten.cfg
#
#  (DONE) add basic replication test, which runs when there is no load
#
#  (DONE) get the calls to cctrl without filtering them with grep, to have a more complete log of the operations
#
#  (DONE) add a feature that restarts all mysql servers
#
#  (DONE) add a feature that collects the logs of all nodes into a tarball
#
#


{

package CLI_Utils;
#
# This package has been inserted in this code for easy portability.
# The main code starts ~ 620 lines below
#

use strict;
use warnings;
use English '-no_match_vars';
use Getopt::Long;
use Data::Dumper;
use File::Basename;
use Carp;

require Exporter;

our @ISA = qw(Exporter);

our $VERSION = '0.01';
our $VERBOSE = $ENV{CLI_VERBOSE} || 0;
our $DEBUG = $ENV{CLI_DEBUG} || 0;

my %default_options = (
    # cgi => {
    #        parse   => 'cgi',
    #        value   => 0,
    #        so      => 900,
    #        groups  => ['all', 'cli-admin'],
    #        help    => ['Generate a CGI form to edit this program options ' ]
    #    },
     verbose => {
            parse   => 'verbose',
            value   => 0,
            so      => 910,
            groups  => ['all', 'cli-admin'],
            help    => ['Show more information during installation and help ' ]
        },
     manual => {
            parse   => 'man|manual',
            value   => 0,
            so      => 920,
            groups  => ['all', 'cli-admin'],
            help    => ['Display the program manual' ]
        },
     version => {
            parse   => 'v|version',
            value   => 0,
            so      => 930,
            groups  => ['all', 'cli-admin'],
            help    => ["Show $PROGRAM_NAME version and exit " ]
        },
     display_options => {
            parse   => 'display-options',
            value   => 0,
            so      => 940,
            groups  => ['all', 'cli-admin'],
            help    => ["Show all the options without running the program" ]
        },
      help => {
            parse   => 'h|help',
            value   => 0,
            so      => 1000,
            groups  => ['all', 'cli-admin'],
            help    => ['Display this help' ]
        },
) ;

sub new
{
    my ($class, $params ) = @_;
    my $main_option;
    my $program_name;
    if ($params)
    {
       if (ref($params))
       {
           if (ref($params) eq 'HASH')
            {
                $program_name =  $params->{program_name};
                $main_option  =  $params->{main_option};
                unless ($program_name)
                {
                    $program_name = basename($PROGRAM_NAME);
                }
            }
            elsif (ref($params) eq 'ARRAY')
            {
                $program_name = $params->[0];
                $main_option  = $params->[1];
            }
            else
            {
                die "can't deal with 'params' of this type (@{[ref($params)]})\n";
            }
        }
        else  # scalar
        {
            $program_name = $params;
        }
    }
    my $self = bless {
        parse_options => \%default_options,
        options => {},
        main_option => $main_option,
        program_name => $program_name,
    }, $class;
    return $self;
}

# Returns a nicely formatted set of options for a command with a long list of arguments
sub pretty_command
{
    my ($cmd, $args) = @_;
    my $indent = ' ' x 4;
    $args =~ s{\s+-}{ \\\n$indent-}g;
    return "$cmd$args\n";
}


sub display_options
{
    my ($self) = @_;
    print $self->get_command_line();
}
 

sub write_options
{
    my ($self) = @_;
    my $cli_history = './cookbook/tungsten-cookbook-command-line.history';
    open my $FH, '>>', $cli_history
        or die "can't write to $cli_history($!)\n";
    print $FH "# ", scalar( localtime), "\n";
    $self->{options}{skip_zeroes}=1;
    $self->{options}{skip_defaults}=1;
    print $FH $self->get_command_line(), "\n";
    $self->{options}{skip_zeroes}=0;
    $self->{options}{skip_defaults}=0;
    close $FH;
}
 
sub get_command_line
{
    my ($self) = @_;
    my $parse_options = $self->{parse_options};
    my $options = $self->{options};
    my $command_line = '';
    for my $op (
                sort { $parse_options->{$a}{so} <=> $parse_options->{$b}{so} }
                grep { $parse_options->{$_}{parse}}  keys %{ $parse_options }
               )
    {
        next unless defined $options->{$op};
        next if $op eq 'skip_zeroes';
        next if $op eq 'skip_defaults';
        if ($options->{skip_zeroes})
        {
            next unless $options->{$op};
        }
        if ($options->{skip_defaults})
        {
            next if $options->{$op} && $parse_options->{$op}{value} && ($options->{$op} eq $parse_options->{$op}{value});
        }
        my $param =  $parse_options->{$op}{parse};
        my (undef, $long ) = $param =~ / (?: (\w+) \| )? ([^\|=]+) /x;
        if (ref($options->{$op}) && (ref($options->{$op}) eq 'ARRAY'))
        {
            $command_line .= ' --' . $long . '=' . "@{$options->{$op}}"; 
        }
        else
        {
            if ($parse_options->{$op}{parse} =~ /=/)
            {
                $command_line .= ' --' . $long . '=' . $options->{$op}; 
            }
            else
            {
                $command_line .= ' --' . $long ; 
            }
        }
    }
    # print Dumper $options, $parse_options;
    return pretty_command($PROGRAM_NAME, $command_line);
}

sub process_cgi
{
    my ($self) = @_;
    my $parse_options = $self->{parse_options};
    eval "use CGI qw/:standard *table/; use CGI::Pretty qw(:html3)";
    if ($CHILD_ERROR)
    {
        die "Can't load the CGI module\n";
    }
    my $cgi = CGI::Pretty->new();
    if ($cgi->param())
    {
     
    }
    else
    {
        my $CGI_text = $cgi->header() 
            . $cgi->start_html($self->{program_name} || $PROGRAM_NAME)
            . $cgi->h1($self->{program_name} || $PROGRAM_NAME) 
            . $cgi->start_form()
            . start_table( {border => '1', cellpadding => 5, cellspacing=> 0});
        for my $op (
                sort { $parse_options->{$a}{so} <=> $parse_options->{$b}{so} }
                grep { $parse_options->{$_}{parse}}  keys %{ $parse_options }
               )
        {
           my $parse = $parse_options->{$op}{parse} ;

           my (undef, $long ) = $parse =~ / (?: (\w+) \| )? ([^\|=]+) /x;

           if ($parse_options->{$op}{allowed})
           {
                $CGI_text .= 
                    Tr(td(
                    b($long),
                     p(), 
                    radio_group(
                    -name   =>  $op, 
                    -values =>  [ keys %{ $parse_options->{$op}{allowed} } ],
                    -linebreak => 'true',
                    -default => $self->{options}{$op} || $parse_options->{$op}{value})  
                    ),
                    td(i( join ' ', @{ $parse_options->{$op}{help} } ))
                    )
                . p(); 
           }
           elsif ($parse =~ /=[si]/) 
           {
                $CGI_text   .= 
                            Tr(td(
                            b($long), 
                             ' ',
                            textfield (
                                -name  => $op,
                                -value =>$self->{options}->{$op} || $parse_options->{$op}{value} ) 
                             ),
                             td(i( join ' ', @{ $parse_options->{$op}{help} } ))
                             )
                            . p();
           }
           else 
           {
               $CGI_text .= 
                            Tr(td(
                            checkbox(
                                -name => $op,
                                -label => $long, 
                                -checked => $self->{options}{$op} || $parse_options->{$op}{value} ? '1' : '0',
                                )
                            ),
                            td( i(join ' ', @{ $parse_options->{$op}{help} }) )
                            )
                            . p()
           }
        }
        $CGI_text .=  end_table()
                     . submit(-name => 'submit', -value => "get $self->{program_name} options")
                     . end_form() . hr() . end_html();
        print $CGI_text; 
    } 
    exit;
}


sub getoptions
{
    my ($self) = @_;
    my $parse_options = $self->{parse_options};
    if ($self->{program_name})
    {
        my $prefix = $self->{program_name};
        $prefix =~ s/\W/_/g; 
        for my $op (keys %{ $parse_options} )
        {
            my $key = uc "${prefix}_$op";
            if ($ENV{$key})
            {
                $parse_options->{$op}{value} = $ENV{$key};
            }
        } 
    }
    my %options = map { $_ ,  $parse_options->{$_}{'value'}}  keys %{$parse_options};
    $self->before_parsing();
    GetOptions (
        map { $parse_options->{$_}{parse}, \$options{$_} }    
        grep { $parse_options->{$_}{parse}}  keys %{$parse_options} 
    ) or $self->get_help('');

    $self->{options}= \%options;
    if ($options{cgi})
    {
        $self->process_cgi();
    }
    if ($options{display_options})
    {
        $self->display_options();
        exit 0;
    }
    if ($options{version})
    {
        print $self->get_credits();
        exit 0;
    }
    $VERBOSE = $options{verbose} if $options{verbose};
    $self->get_help() if $options{help};
    get_manual()      if $options{manual};
    $self->after_parsing();
    $self->validate();
}

my %options_fields = 
(
    parse       => 1, 
    help        => 1,
    so          => 1,
    value       => 0,
    short       => 0,
    long        => 0,
    must_have   => 0,
    allowed     => 0,
    groups      => 0,
    display     => 0,
    hide        => 0,
);

sub add_option 
{
    my ($self, $option_name, $option, $replace) = @_;
    unless ($option_name)
    {
        die "Option_name parameter required for add_option\n";
    }

    if ($replace && (! $self->{parse_options}{$option_name}))
    {
        die "Option '$option_name' does not exist: Can't replace.\n";
    }

    if ($self->{parse_options}{$option_name} && (! $replace ))
    {
        die "Option '$option_name' already exists\n";
    }

    unless ($option)
    {
        die "Option parameter required for add_option\n";
    }

    if (! ref($option) or (ref($option) ne 'HASH'))
    {
        die "The 'option' parameter must be a hash ref\n";
    }

    for my $field (keys %{ $option} )
    {
        die "unrecognized field '$field' \n" unless exists $options_fields{$field};
    }

    if ($option->{short} || $option->{long})
    {
        if ($option->{parse})
        {
            die "You must provide either 'parse' or 'short' and 'long', but not both\n";
        }
        $option->{parse} = $option->{short} . '|' . $option->{long};
    }

    for my $field (grep {$options_fields{$_}} keys %options_fields)
    {
        die "field '$field' must exist in option\n" unless exists $option->{$field};
    }

    if (! ref $option->{help})
    {
        $option->{help} = [$option->{help}];
    }

    if (ref($option->{help}) ne 'ARRAY')
    {
        die "the 'help' field in option $option_name must be an array of strings\n";
    }

    if ($option->{allowed})
    {
        my $allowed = $option->{allowed};
        if (ref $allowed )
        {
            if (ref $allowed eq 'ARRAY')
            {
                my %new_allowed;
                for my $f (@{ $option->{allowed} })
                {
                    $new_allowed{$f} = 1;
                }
                $option->{allowed} = \%new_allowed;
            }
        }
        else
        {
            $option->{allowed} = { $allowed => 1};
        }
    }
    my %parse_elements = map { s/=\w+//; $_=> 1} split(/\|/, $option->{parse});
    my @clashing_elements = ();
    for my $opt (keys %{$self->{parse_options}} )
    {
        my @existing_parse_elements = map {s/=\w+//; $_} split(/\|/, $self->{parse_options}{$opt}{parse});
        for my $element (@existing_parse_elements)
        {
            #print "++ $element\n";
            if ( exists $parse_elements{$element})
            {
                push @clashing_elements, 
                "Parsing clash: $option_name:<$option->{parse}>  vs. $opt: <$self->{parse_options}{$opt}{parse}>\n"
                . "Element <$element> from '$option_name' already defined in option '$opt'\n\n";
            }
        }
    }
    if (@clashing_elements)
    {
        for my $item (@clashing_elements)
        {
            warn $item;
        }
        confess "There were clashing items - halting the program\n";
    }
    $self->{parse_options}{$option_name} = $option;
    return $self;
}

sub validate
{
    my ($self) = @_;
    my ($options, $parse_options) = ($self->{options}, $self->{parse_options});
    my @to_be_defined;
    my @not_allowed;
    my $must_exit = 0;
    #
    # Checks that required options are filled
    #
    for my $must ( grep {$parse_options->{$_}->{must_have}} keys %{$parse_options})
    {
        unless (defined $options->{$must})
        {
            my $required = 0;
            if ( ! $self->{main_option} 
                && 
                ref($parse_options->{$must}->{must_have}) 
                && 
                ref($parse_options->{$must}->{must_have}) eq 'ARRAY' )
            {
                warn  "The option $must was defined as depending on a set of values\n"
                    . "(@{$parse_options->{$must}->{must_have}})\n"
                    . "but the 'main_option' label was not set in the constructor\n"; 
                $must_exit = 1;
            }
 
            if ($self->{main_option} 
                && 
                ref($parse_options->{$must}->{must_have}) 
                && 
                ref($parse_options->{$must}->{must_have}) eq 'ARRAY' )
            # 
            # Conditional requirement, with a list of tasks where it is required
            # Using information in the parsing options, this loop determines if 
            # some options must be filled or not.
            {
                for my $task (@{$parse_options->{$must}->{must_have}})
                {
                    # print Dumper($self->{main_option}, $task);
                    if (($self->{main_option}) 
                        &&  
                        ($options->{$self->{main_option}} )
                        &&  
                        ($task eq $options->{$self->{main_option}}))
                    {
                        $required = 1;
                    }
                }
            }
            elsif ($parse_options->{$must}->{must_have} eq '1')
            # unconditional requirement
            {
                $required=1;
            }
            push @to_be_defined, $must if $required;
        }
    }

    #
    # Checks that options requiring given keywords are not using anything different
    #
    for my $option (keys %{$options} ) {
        if (exists $parse_options->{$option}{allowed} && $options->{$option})
        {
            if (ref($options->{$option}) && ref($options->{$option}) eq 'ARRAY')
            {
                for my $item (@{$options->{$option}})
                {
                    unless (exists $parse_options->{$option}{allowed}{$item})
                    {
                        push @not_allowed, "Not allowed value '$item' for option '$option' - "
                        . " (Choose among: { @{[keys %{$parse_options->{$option}{allowed}} ]} })\n";
                    }
                }
            }
            else
            {
                unless (exists $parse_options->{$option}{allowed}{$options->{$option}})
                {
                    push @not_allowed, "Not allowed value '$options->{$option}' for option '$option' - "
                    . " (Choose among: { @{[keys %{$parse_options->{$option}{allowed}} ]} })\n";
                }
            }
        }
    }
    #
    # Reports errors, if any
    #
    if (@to_be_defined)
    {
        for my $must (@to_be_defined)
        {
            print "Option '$must' must be defined\n"
        }
    }
    if (@not_allowed)
    {
        for my $na (@not_allowed) 
        {
            print $na;
        }
    }
    if (@not_allowed or @to_be_defined or $must_exit)
    {
        exit 1;
    }
}
 
sub get_layout
{
    my $self = (@_);
    return '[options] operation';
}

sub get_help {
    my ($self, $msg) = @_;
    my $parse_options = $self->{parse_options};
    if ($msg) {
        warn "[***] $msg\n\n";
    }

    my $layout = $self->get_layout();
    my $HELP_MSG = q{};
    for my $op (
                sort { $parse_options->{$a}{so} <=> $parse_options->{$b}{so} }
                grep { $parse_options->{$_}{parse}}  keys %{ $parse_options }
               )
    {
        my $param =  $parse_options->{$op}{parse};
        my $param_str = q{    };
        my ($short, $long ) = $param =~ / (?: (\w+) \| )? (\S+) /x;
        if ($short)
        {
            $param_str .= q{-} . $short . q{ };
        }
        $long =~ s/ = s \@? / = name/x;
        $long =~ s/ = i / = number/x;
        $param_str .= q{--} . $long;
        $param_str .= (q{ } x (40 - length($param_str)) );
        my $text_items = $parse_options->{$op}{help};
        my $item_no=0;
        for my $titem (@{$text_items})
        {
            $HELP_MSG .= $param_str . $titem ;
            if (++$item_no == @{$text_items})
            {
                if ($VERBOSE && $parse_options->{$op}{value}) 
                {
                    if (length($parse_options->{$op}{value}) > 40)
                    {
                        $HELP_MSG .= "\n" . q{ } x 40;
                    }
                    $HELP_MSG .=  " ($parse_options->{$op}{value})";
                }
            }
            $HELP_MSG .= "\n";
            $param_str = q{ } x 40;
        }
        if ($VERBOSE && $parse_options->{$op}{must_have}) 
        {
            if (ref$parse_options->{$op}{must_have})
            {
                $HELP_MSG .=  (q{ } x 40) . "(Must have for: @{[join ',', sort @{$parse_options->{$op}{must_have}}  ]})\n"
            }
            else 
            {
                $HELP_MSG .= (q{ } x 40) . '(Must have)' . "\n";
            }
        }
        if ($VERBOSE && $parse_options->{$op}{allowed}) 
        {
            $HELP_MSG .=  (q{ } x 40) . "(Allowed: {@{[join '|', sort keys %{$parse_options->{$op}{allowed}}  ]}})\n"
        }
   }

   print $self->get_credits(),
          "Syntax: $self->{program_name} $layout \n",
          $HELP_MSG;
    exit( defined $msg );
}
 
sub get_manual
{
    my $perldoc = which('perldoc');
    if ($perldoc)
    {
        exec "perldoc $PROGRAM_NAME";
    }
    else
    {
        die  "The 'perldoc' program was not found on this computer.\n"
            ."You need to install it if you want to see the manual\n";
    }
}

#
# Custom implementation of the 'which' command.
# Returns the full path of the command being searched, or NULL on failure.
#
sub which
{
    my ($executable) = @_;
    if ( -x "./$executable" )
    {
        return "./$executable";
    }
    for my $dir ( split /:/, $ENV{PATH} )
    {
        $dir =~ s{/$}{};
        if ( -x "$dir/$executable" )
        {
            return "$dir/$executable";
        }
    }
    return;
}

sub resolveip
{
    my ($hostname) = @_;
    if ($hostname =~ /^\d+\.\d+\.\d+\.\d+$/)
    {
        return $hostname;
    }
    # if resolveip is found, this is the preferred method
    if ($CLI_Utils::VERBOSE)
    {
        print "# Attempting IP resolution using 'resolveip -s $hostname'\n";
    }
    my $resolveip = which('resolveip');
    if ($resolveip)
    {
        my $ip = qx/$resolveip -s $hostname/;
        chomp $ip;
        return $ip;
    }
    # Alternative #1: we parse /etc/host
    if ($CLI_Utils::VERBOSE)
    {
        print "# Attempting IP resolution parsing '/etc/hosts'\n";
    }
     my @lines = slurp('/etc/hosts');
    for my $line (@lines)
    {
        if ($line =~ /^\s*(\d+\.\d+\.\d+\.\d+).*\b$hostname\b/)
        {
            return $1;
        }
    }
    # Alternative #2: we use ping
    if ($CLI_Utils::VERBOSE)
    {
        print "# Attempting IP resolution using 'ping -c1 $hostname'\n";
    }
    my $ping = which('ping');
    if ($ping)
    {
        my $ping_text = qx/$ping -c1 $hostname/;
        if ($ping_text =~ /\((\d+\.\d+\.\d+\.\d+)\)/)
        {
            return $1
        }
    }
    die "Can't resolve IP for $hostname\n";
}


sub get_credits
{
    my ($self) = @_;
    return "Should override 'get_credits'\n";
}   

sub before_parsing
{
    my ($self) = @_;
    # warn "Should override 'before_parsing'\n";
}

sub after_parsing
{
    my ($self) = @_;
    #warn "Should override 'after_parsing'\n";
}

sub slurp
{
    my ($filename) = @_;
    open my $FH , '<', $filename
        or die "can't open $filename\n";
    my @lines = <$FH>;
    close $FH;
    if (wantarray)
    {
        return @lines;
    }
    else
    {
        my $text ='';
        $text .= $_ for @lines;
        chomp $text;
        return $text;
    }
}

sub get_cfg
{
    my ($fname) = @_;
    my $cfg = slurp($fname);
    $cfg =~ s/:/=>/g;
    $cfg = '$cfg=' . $cfg;
    eval $cfg;
    if ($@)
    {
        die "error evaluating contents of $fname\n";
    }
    return $cfg;
}



1;
} # end package CLI_Utils


{
package Cookbook;

my $VERSION = '1.2.18';
use base qw(CLI_Utils);
sub get_credits
{
    return   "The Cookbook Helper\n"
           . "version $VERSION\n"
           . "(C) Continuent, Inc, 2012,2013\n";
}

sub get_layout
{
    return   "[options] [recipe]";
}

}  # end package Cookbook

package main;

$SIG{INT} = 'trap_int';

##############################################
# Defining the cookbook command line options
##############################################
my $cli = Cookbook->new(
    {
        program_name => 'cookbook',
        main_option  => undef,
    }
);

$cli->add_option(
    list => {
        parse       => 'l|list',
        value       => 0,
        must_have   => 0,
        so          => 20,
        help        => ['Show existing cookbook recipes'],
    }
);

$cli->add_option(
    show => {
        parse       => 's|show',
        value       => 0,
        must_have   => 0,
        so          => 30,
        help        => ['Show the recipe'],
    }
);

$cli->add_option(
    dry_run => {
        parse       => 'dry-run',
        value       => 0,
        must_have   => 0,
        so          => 40,
        help        => ['Only show the recipe, without running it'],
    }
);

$cli->add_option(
    shortcut_dir => {
        parse       => 'shortcut-dir=s',
        value       => 'continuent-tungsten',
        must_have   => 0,
        so          => 46,
        help        => ['Name of the shortcut directory to Tungsten installation under $HOME'],
    }
);

$cli->add_option(
    no_shortcuts => {
        parse       => 'no-shortcuts',
        value       => 0,
        must_have   => 0,
        so          => 45,
        help        => ['Do not create shortcuts to Tungsten installation in $HOME/' . $cli->{parse_options}{shortcut_dir}{value}],
    }
);




$cli->add_option(
    run_test => {
        parse       => 'run-test',
        value       => 0,
        must_have   => 0,
        so          => 50,
        help        => ['If a test exists for this recipe, run it'],
    }
);


$cli->add_option(
    tests => {
        parse       => 'tests=s@',
        value       => undef,
        allowed     => [qw(replication switch failover recover cswitch cfailover crecover contents all )],
        must_have   => 0,
        so          => 55,
        help        => ['run additional tests'],
    }
);

$cli->add_option(
    copy_backups => {
        parse       => 'copy-backups',
        value       => 0,
        must_have   => 0,
        so          => 57,
        help        => ['Copies backups to all other hosts'],
    }
);


$cli->add_option(
    backup_first => {
        parse       => 'backup-first',
        value       => 0,
        must_have   => 0,
        so          => 58,
        help        => ['Takes a backup before starting additional tests'],
    }
);

$cli->add_option(
    more_options => {
        parse       => 'more-options=s@',
        value       => undef,
        must_have   => 0,
        so          => 60,
        help        => ['Add more options to the chosen recipe'],
    }
);

$cli->add_option(
    skip_install => {
        parse       => 'skip-install',
        value       => 0,
        must_have   => 0,
        so          => 65,
        help        => ['Do not run the installation (useful for running the test several times)'],
    }
);

$cli->add_option(
    values_file => {
        parse       => 'values-file=s',
        value       => 'USER_VALUES.sh',
        must_have   => 1,
        so          => 80,
        help        => ["Changes the file containing the user's values"],
    }
);

$cli->add_option(
    start_load => {
        parse       => 'start-load',
        value       => undef,
        must_have   => 0,
        so          => 90,
        help        => ["Starts Bristlecone load before the test"],
    }
);

$cli->add_option(
    fast_load => {
        parse       => 'fast-load',
        value       => undef,
        must_have   => 0,
        so          => 92,
        help        => ["Ise fast Bristlecone setup for data load"],
    }
);

$cli->add_option(
    stop_load_at_end => {
        parse       => 'stop-load',
        value       => undef,
        must_have   => 0,
        so          => 95,
        help        => ["Stops Bristlecone load before quitting the program"],
    }
);

$cli->add_option(
    channels => {
        parse       => 'channels=i',
        value       => undef,
        must_have   => 0,
        so          => 96,
        help        => ["Enables parallel replication with the indicated channels"],
    }
);

$cli->add_option(
    parallelization_type => {
        parse       => 'parallelization-type=s',
        value       => 'disk',
        allowed     => [qw(disk memory)],
        must_have   => 0,
        so          => 97,
        help        => ["sets parallel replication using the given type "],
    }
);

$cli->add_option(
    fail_on_undefined => {
        parse       => 'fail-on-undefined',
        value       => 0,
        must_have   => 0,
        so          => 100,
        help        => ["Fails if lines contain undefined values (default: skips them)"],
    }
);

$cli->add_option(
    skip_vars => {
        parse       => 'skip-vars=s',
        value       => undef,
        must_have   => 0,
        so          => 110,
        help        => ["Skips given variables "],
    }
);

my $cookbook_directory = abs_path(dirname($PROGRAM_NAME));
# 
# remove trailing slash from cookbook directory
#
$cookbook_directory =~ s{/$}{};
$cookbook_directory =~ s{/\.test$}{};

my $install_directory = $cookbook_directory;
#
# removes directory name from cookbook directory, to find the installation directory
#
$install_directory =~ s{/[^/]+$}{};

$cli->add_option(
    cookbook_directory => {
        parse       => 'cookbook-directory=s',
        value       => $cookbook_directory,
        must_have   => 0,
        so          => 110,
        help        => ["Changes the file containing the user's values"],
    }
);

$cli->add_option(
    uninstall_cluster => {
        parse       => 'uninstall-cluster',
        value       => 0,
        must_have   => 0,
        so          => 110,
        help        => ["Removes a cluster deployed with the given recipe", 
                        "[WARNING] : this option will delete files and remove DB schemas "],
    }
);

$cli->add_option(
    force_uninstall => {
        parse       => 'force-uninstall',
        value       => 0,
        must_have   => 0,
        so          => 115,
        help        => ["Forces the removal of a cluster even if the preliminary check fails"] ,
    }
);

$cli->add_option(
    collect_logs => {
        parse       => 'collect-logs',
        value       => 0,
        must_have   => 0,
        so          => 116,
        help        => ["Collect the manager, replicator, and connector logs of all nodes into a tarball"]
    }
);


$cli->add_option(
    logs_store_dir => {
        parse       => 'logs-store-dir=s',
        value       => undef,
        must_have   => 0,
        so          => 120,
        help        => ["If given, stores the logs in this directory"]
    }
);

$cli->add_option(
    logs_store_name => {
        parse       => 'logs-store-name=s',
        value       => undef,
        must_have   => 0,
        so          => 122,
        help        => ["How to name the logs compressed archive"]
    }
);



$cli->add_option(
    logs_s3_bucket => {
        parse       => 'logs-s3-bucket=s',
        value       => undef,
        must_have   => 0,
        so          => 125,
        help        => ["If given. saves the logs in this bucket (requires a properly tuned aws tool)"]
    }
);






#$cli->add_option(
#    check_cluster => {
#        parse       => 'check-cluster',
#        value       => 0,
#        must_have   => 0,
#        so          => 120,
#        help        => ["Check a cluster for existing deployments and basic installation conditions"],
#    }
#);


$cli->add_option(
    debug => {
        parse       => 'debug=i',
        value       => 0,
        must_have   => 0,
        so          => 130,
        help        => ["Increases the amount of information given during execution.",
                        "Use --debug=3 to see the output of every command given"],
    }
);

$cli->add_option(
    log => {
        parse       => 'log',
        value       => 0,
        must_have   => 0,
        so          => 135,
        help        => ["Saves all test commands and their output to a given file"],
    }
);


$cli->add_option(
    log_file => {
        parse       => 'log-file=s',
        value       => 'tungsten-cookbook-TIMESTAMP.log',
        must_have   => 0,
        so          => 137,
        help        => ["Define the file name for logging (requires --log)"],
    }
);

$cli->add_option(
    demo => {
        parse       => 'demo',
        value       => 0,
        must_have   => 0,
        so          => 138,
        help        => ["Show what is happening and waits for input before the next action"],
    }
);

$cli->add_option(
    demo_delay => {
        parse       => 'demo-delay=i',
        value       => 0,
        must_have   => 0,
        so          => 139,
        help        => ["Sets a delay between steps of a demo. No manual intervention allowed."],
    }
);

$cli->add_option(
    cctrl_options => {
        parse       => 'cctrl-options=s',
        value       => '',
        must_have   => 0,
        so          => 140,
        help        => ['Gets options that should be passed to cctrl' ],
    }
);

$cli->add_option(
    template => {
        parse       => 'template=s',
        value       => undef,
        must_have   => 0,
        so          => 150,
        help        => ['Which template we should use. It can also be passed straight at the end of the command line' ],
    }
);

$cli->add_option(
    ssh_port => {
        parse       => 'ssh-port=i',
        value       => 22,
        must_have   => 0,
        so          => 160,
        help        => ['Which port we use for SSH and scp commands (default: 22)' ],
    }
);


$cli->add_option(
    ssh_user => {
        parse       => 'ssh-user=s',
        value       => $ENV{USER} || 'tungsten',
        must_have   => 0,
        so          => 165,
        help        => ['Which user for SSH and scp commands (default: '.  ($ENV{USER} || 'tungsten') .')' ],
    }
);





$cli->add_option(
    cluster_status => {
        parse       => 'cluster-status',
        value       => 0,
        must_have   => 0,
        so          => 180,
        help        => ["Displays a detailed cluster status"],
    }
);

$cli->add_option(
    log_cluster_status => {
        parse       => 'log-cluster-status',
        value       => 0,
        must_have   => 0,
        so          => 190,
        help        => ["Records a detailed cluster status in the logs"],
    }
);

$cli->add_option(
    test_installed => {
        parse       => 'test-installed',
        value       => 0,
        must_have   => 0,
        so          => 200,
        help        => ["Sets all the needed options to test from an installed directory"],
    }
);

$cli->add_option(
    fail_command => {
        parse       => 'fail-command=s',
        value       => 'mysqladmin',
        must_have   => 0,
        allowed     => [qw(mysqladmin service)],
        so          => 210,
        help        => ["Use the given method to trigger a failover test"],
    }
);

$cli->add_option(
    enable_witness => {
        parse       => 'enable-witness',
        value       => undef,
        must_have   => 0,
        so          => 220,
        help        => ["Enables a witness in the installation recipe. It will be skipped unless this option is enabled."],
    }
);

$cli->add_option(
    the_works => {
        parse       => 'the-works|full-test',
        value       => undef,
        must_have   => 0,
        so          => 230,
        help        => ["Enables a all the testing options at once."],
    }
);



#
#  Fake option to test uniqueness of parsing parameters
#
if ($ENV{TEST_FAKE_OPTION})
{
    $cli->add_option(
        clashing_option => {
            parse       => 'template=i|list|l',
            #parse       => 'template=i',
            value       => 0,
            must_have   => 0,
            so          => 826,
            help        => ["this is a fake option that we use to test the uniqueness of commands"],
        }
     );
}




my $SSH_USER= $ENV{USER} || 'tungsten';
my $SSH_PORT=22;
my $SSH = 'ssh';
my $SCP = 'scp';

my $backup_taken = 0;
my $MYCCTRL = 'cctrl';
my $TUNGSTEN_SCHEMA  = $ENV{TUNGSTEN_SCHEMA} || 'tungsten';
my $tungsten_version = 1;
my %full_tungsten_version;
my $MYCCTRL_OPTIONS  = '';
my $fail_method = 'mysqladmin';
my $continuent_tungsten_staging_directory = 'continuent_tungsten_staging_directory.info';
if ($ENV{CCTRL_OPTIONS})
{
    $MYCCTRL_OPTIONS = ' ' . $ENV{CCTRL_OPTIONS} . ' ';
}
my %test_outcome =
(
    all  => 0,
    pass => 0,
    fail => 0,
);
my $logging = 0;
my $skip_status_in_log = 0;
our $demoing = 0;
my $first_demo_prompt=1;
my $demo_delay = 0;
my $log_file = '';
my $current_options = undef;

sub get_cctrl
{
    my ($user_values) = @_;
    return "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-manager/bin/$MYCCTRL";
}

sub get_cctrl_with_options
{
    my ($user_values) = @_;
    unless (ref($user_values) && (ref($user_values) eq 'HASH'))
    {
        use Carp;
        croak "\$user_values is not a hash\n";
    }
    my $cctrl = "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-manager/bin/$MYCCTRL";
    if ($MYCCTRL_OPTIONS)
    {
        $cctrl .= ' ' . $MYCCTRL_OPTIONS;
    }
    return $cctrl;
}

######################################
# main code
######################################

my $template_extension = '.tmpl';

$cli->getoptions();

if ($cli->{options}{the_works})
{
    $cli->{parse_options}{verbose}{value}=1;
    $cli->{options}{verbose}=1;
    $cli->{parse_options}{run_tests}{value}=1;
    $cli->{options}{run_test}=1;
    $cli->{parse_options}{tests}{value}=['all'];
    $cli->{options}{tests}=['all'];
    $cli->{options}{log}=1;
    $cli->{parse_options}{log}{value}=1;
    $cli->{parse_options}{copy_backups}{value}=1;
    $cli->{options}{copy_backups}=1;
    $cli->{parse_options}{start_load}{value}=1;
    $cli->{options}{start_load}=1;
    $cli->{parse_options}{fast_load}{value}=1;
    $cli->{options}{fast_load}=1;
    #$cli->after_parsing();
    #$cli->validate();
}

unless ( -x "$install_directory/tools/tpm")
{
    die "Could not find tpm in $install_directory/tools";
}
chdir $install_directory;

$SSH = "ssh -p $cli->{options}{ssh_port} ";
$SCP = "scp -P $cli->{options}{ssh_port} ";
$SSH_USER = $cli->{options}{ssh_user} ;
$fail_method = $cli->{options}{fail_command};

my @manifest_lines = CLI_Utils::slurp('.manifest.json');
for my $line (@manifest_lines)
{
    
    for my $label (qw(major minor revision buildNumber))
    {
        if ($line =~ /"$label":\s*(\d+)/)
        {
            $full_tungsten_version{$label} = $1;
        }
        last if $full_tungsten_version{buildNumber};
    }
}
$tungsten_version = $full_tungsten_version{major}
    or die "Can't determine major Tungsten version\n";
 

if ($cli->{options}{test_installed})
{
    my $template = "$cookbook_directory/INSTALLED.tmpl";
    my $values_file = "$cookbook_directory/INSTALLED_USER_VALUES.sh";
    for my $file (($template, $values_file))
    {
        unless ( -f $file)
        {
            die "could not find $file\n";
        }
    }
    $cli->{options}{values_file} = $values_file;
    $cli->{options}{template} = 'INSTALLED';
    $cli->{options}{skip_install} = 1;
    $cli->{options}{run_test} = 1;
    $cli->{options}{verbose} = 1;
    $CLI_Utils::VERBOSE=1;
    shift;
}


if ($cli->{options}{log_cluster_status} && (! $cli->{options}{log}))
{
    die "if you need --log-cluster-status, you must also enable logging\n";
}

# 
# 'list' is the only action that can run without a template name
#
if ($cli->{options}{list})
{
    list_templates($cli->{options});
    exit 0;
}
else
{
    unless ($cli->{options}{template})
    {
        $cli->get_help('missing template') unless @ARGV;
        $cli->{options}{template} = shift;
    }
}

$cli->write_options();

if ($cli->{options}{debug})
{
    $CLI_Utils::DEBUG= $cli->{options}{debug};
}


if ($cli->{options}{log})
{
    $logging=1;
    $log_file = $cli->{options}{log_file};
    $log_file =~ s/TIMESTAMP/get_timestamp()/e;
    print_log(undef);
}

if ($cli->{options}{cctrl_options})
{
    $MYCCTRL_OPTIONS .= ' '. $cli->{options}{cctrl_options} . ' ';
}

if ($cli->{options}{tests})
{
    my @tests = @{ $cli->{options}{tests}};
    $cli->{options}{tests} = {};
   
    $cli->{options}{tests}{$_} = 1 for @tests; 
    if ($cli->{options}{tests}{'all'})
    {
        # print Dumper $cli->{parse_options}; exit;
        for my $allowed ( keys  %{ $cli->{parse_options}{tests}{allowed} } )
        {
            $cli->{options}{tests}{$allowed} =1;
        }
        delete $cli->{options}{tests}{'all'};
    }
    if ($cli->{options}{tests}{'contents'})
    {
        unless ($cli->{options}{start_load})
        {
            $cli->{options}{tests}{'contents'} = 0; 
        }
    }
    if ($cli->{options}{tests}{'recover'})
    {
        $cli->{options}{tests}{'failover'} = 1;
    }
    if ($cli->{options}{tests}{'crecover'})
    {
        $cli->{options}{tests}{'cfailover'} = 1;
    }
}

# print Dumper $cli->{options}; exit;

#
# The values file is first searched in the current directory, unless it is a full path name
# Then in the templates directory.
#
unless (-f $cli->{options}{values_file})
{
    my $values_file = basename($cli->{options}{values_file});
    $cli->{options}{values_file} = "$cli->{options}{cookbook_directory}/$values_file";
    unless (-f $cli->{options}{values_file})
    {
        die "can't find values file $cli->{options}{values_file}\n";
    }
}

if ($cli->{options}{skip_vars})
{
    my %to_skip = map {$_ => 1} split /[,:]/, $cli->{options}{skip_vars};
    $cli->{options}{skip_vars} = \%to_skip;
}

#
# Process which action (or actions) we should run
# (dry runs are handled inside each action subroutine)
#

if ($cli->{options}{show})
{
    show_template($cli->{options});
    exit;
}
elsif ($cli->{options}{uninstall_cluster})
{
    if ($cli->{options}{run_test})
    {
        die "incompatible options 'run-test' and 'uninstall-cluster'\n";
    }
    # Need to fill the template, to know which hosts we should uninstall
    fill_template($cli->{options});
    if ($cli->{options}{collect_logs})
    {
        collect_logs($cli->{options})
    }
    uninstall_cluster($cli->{options});
}
elsif ($cli->{options}{skip_install} && (! $cli->{options}{run_test} ) && $cli->{options}{start_load})
{
    fill_template($cli->{options});
    start_load($cli->{options});
}
elsif ($cli->{options}{skip_install} && (! $cli->{options}{run_test} ) && $cli->{options}{stop_load_at_end})
{
    stop_load();
    exit;
}
elsif ($cli->{options}{skip_install} && $cli->{options}{run_test})
{
    # Need to fill the template, to get testing info
    fill_template($cli->{options});
    run_test($cli->{options});
}
elsif ($cli->{options}{skip_install} && $cli->{options}{collect_logs})
{
    # Need to fill the template, to get testing info
    fill_template($cli->{options});
    collect_logs($cli->{options});
}
elsif ($cli->{options}{cluster_status} && (! $cli->{options}{run_test}))
{
    fill_template($cli->{options});
    print get_cluster_status($cli->{options});
}
else 
{   # We just run the recipe

    run_recipe($cli->{options});
    if ($cli->{options}{run_test})
    {
        run_test($cli->{options})
    }
    elsif ($cli->{options}{collect_logs})
    {
        collect_logs($cli->{options})
    }
}


######################################
# tungsten-cookbook specific routines
######################################


######################################################
# List templates
# looks inside the cookbook directory and 
# lists all files with extension $template_extension
#####################################################
sub list_templates
{
    my ($options) = @_;
    die "no cookbook_directory found\n" unless $options->{cookbook_directory};
    die "$options->{cookbook_directory} not found or not a directory \n" unless -d $options->{cookbook_directory};
    
    my $curdir = getcwd();
    chdir $options->{cookbook_directory};
    my @templates = glob("*$template_extension");
    for my $template(@templates)
    {
        # 
        # Reads the template
        # If a line starting with template name and ":" is found, 
        # it is taken as the template description
        #
        my @lines = CLI_Utils::slurp($template);
        my $comment = '';
        $template =~ s/\Q$template_extension\E$//;
        for my $line (@lines)
        {
            if ($line =~ /^\s*#\s*$template\s*:\s*(.*)/i)
            {
                $comment = ": $1";
                last;
            }
        }
        printf "%-20s %s\n", $template, $comment;
    }
    chdir $curdir;
}

########################################################
# show template
# Shows the bare template, without variable replacement
########################################################
sub show_template
{
    my ($options) = @_;
    die "no cookbook_directory found\n" unless $options->{cookbook_directory};
    die "$options->{cookbook_directory} not found or not a directory \n" unless -d $options->{cookbook_directory};
    my $template =  "$options->{cookbook_directory}/$options->{template}";
    unless (-f $template)
    {
        if ($template =~ /\Q$template_extension\E$/)
        {
            die "could not find $template\n"; 
        }
        else
        {
            $template .= $template_extension;
            die "template $template not found\n" unless -f $template;
        }
    }
    my @lines = CLI_Utils::slurp($template);
    print @lines;
}


sub get_members
{
    my ($user_values, $host_list_option, $host_list, $master_count, $label) = @_;
    # print "++",$label, "\n", Dumper \@_;
    
    my @ds_hosts = split /,/, $host_list;
    my $members_list='';
    my $which_master=0;
    if ($master_count)
    {
        SEARCH_MASTER:
        for my $host (@ds_hosts)
        {
            for my $master_num (1 .. $master_count)
            {
                if ($user_values->{"MASTER$master_num"} eq $host)
                {
                    $which_master =$master_num;
                    last SEARCH_MASTER;
                }
            }
        }
        unless ($which_master)
        {
            die "No master specified in $host_list_option\n"
        }
    }
    else 
    {
        $which_master='';
    }
    for my $host (@ds_hosts)
    {
        # print "++$host" . $user_values->{"MASTER$which_master"}. "\n";
        next if ($master_count && ($user_values->{"MASTER$which_master"} eq $host));
        if ($members_list)
        {
            $members_list .= ',';
        }
        $members_list .= $host;
    }
    return ("$label$which_master", $members_list); 
}

######################################################
# fill template
# Replaces every $VARIABLE in the template with values
# taken from the user values file. 
#
######################################################

sub fill_template 
{
    my ($options) = @_;
    my $install_server_hostname = qx/hostname/;
    chomp $install_server_hostname;
    # 
    # reads the user values
    #
    my @user_lines = CLI_Utils::slurp($options->{values_file});
    my %user_values;
    my %cluster_info;
    my %deployment_info;
    #
    # Fills the user values that will be used for variable replacement
    #
    for my $line (@user_lines)
    {
        next if $line =~ /^\s*$/;
        next if $line =~ /^\s*#/;
        if ($line =~ /^\s*(?:export\s+)?(\w+)\s*=\s*(.+)/)
        {
            my ($key, $value) = ($1, $2);
            $value =~ s/\s*$//;
            $value =~ s/^['"]//;
            $value =~ s/['"]$//;
            $user_values{$key} = $value;
        }
    }
    #
    # Makes sure that all the variables in user values are defined.
    # Meaning that a variable referring to another variable must be defined,
    # or the template is invalid.
    #
    for my $key (keys %user_values)
    {
        while ($user_values{$key} =~ /\$\{?(\w+)\}?/g)
        {
            my $var = $1;
	        # print "[$key] [$var] ($user_values{$key}) ($user_values{$var})\n" ;
            if (exists $user_values{$var})
            {
                $user_values{$key} =~ s/\$\{?$var\b\}?/$user_values{$var}/g;
            }
            else
            {
                #
                # We may have a reason for skipping variables. If we have
                # used the --skip-vars, the given variable is skipped
                #
                unless ($options->{skip_vars} && $options->{skip_vars}{$key})
                {
                    die "no value found for variable '$key'\n";
                }
            }
        }
    }

    #
    # Adds more_options from the command line to the ones in the user values
    #
    # print ">>> $tungsten_version -- $options->{channels} [$user_values{MORE_OPTIONS}] ($options->{more_options})\n";
    if ($options->{more_options} && @{$options->{more_options}})
    {
        $user_values{MORE_OPTIONS} = '' unless $user_values{MORE_OPTIONS};
        $user_values{MORE_OPTIONS} .= " @{ $options->{more_options} }";
    }
    # print ">>> $tungsten_version -- $options->{channels} [$user_values{MORE_OPTIONS}] ($options->{more_options})\n";
    if (($tungsten_version > 1) && $options->{channels})
    {
        $user_values{MORE_OPTIONS} .= " --svc-parallelization-type=$options->{parallelization_type}  --channels=$options->{channels}"
    }
    # print ">>> $tungsten_version -- $options->{channels} [$user_values{MORE_OPTIONS}] ($options->{more_options})\n";



    # print Dumper \%user_values, $options;exit;
    #
    # Starts filling the recipe text
    #
    my $recipe_text ='';
    unless (-f $options->{template})
    {
        $options->{template} .= '.tmpl';
    }
    #
    # Reads the text
    #
    my @recipe_lines = CLI_Utils::slurp("$options->{cookbook_directory}/$options->{template}");
    my @skipped;
    my $current_ds = undef;
    my $relay_next =0;
    my $written = 0;
    my @processed_recipe_lines;
    my @functional_recipe_lines;
    #
    # First processing pass, to extract vital information needed to identify components
    #
    my $master_count =0;
    my $command = '';
    for my $line (@recipe_lines)
    {
        #$line =~ s/\\$//;
        #$line =~ s/\s*$//;
        if ($line =~ /witness/i)
        {
            unless ($options->{enable_witness})
            {
                next;
            }
        }
        if ($line =~ /(master|dataservice-master-host)\s*=\s*([^\$]\S+)/)
        {
            #print "$line\n";
            my $op=$1;
            my $value=$2;
            unless ($master_count)
            {
                $user_values{MASTER} = $value;
            }
            $master_count++;
            my $end_line='';
            if ($line =~ /\\$/)
            {
                $end_line=q(\\);
            }
            #print Dumper $end_line;
            $user_values{"MASTER$master_count"}=$value;
            $line = "--$op=\$MASTER$master_count $end_line\n";
            #print "$line\n";
        }
        push @processed_recipe_lines, $line;
        next if $line =~ /^\s*#/;
        next if $line =~ /^\s*$/;
        #
        # Reconstructs multi-line commands into single functional ones.
        #
        if ($command)
        {
            $command .= " $line";
        }
        else
        {
            $command = $line;
        }
        chomp ($command);
        if ($command =~ /\\$/)
        {
            $command =~s/\s*\\$//;
        }
        else
        {
            push @functional_recipe_lines, $command;
            $command = '';
        }
    }
    if ($command)
    {
        push @functional_recipe_lines, $command;
    }

    #
    # Uses the whole commands array to identify which master is a relay
    #
    my %relay_masters;
    for my $fline (@functional_recipe_lines)
    {
        if ($fline =~/dataservice-relay-/)
        {
            if ($fline =~  /(?:master|dataservice-master-host)=\$\{?(\w+)\}?/)
            {
                $relay_masters{$1}++;
            }
        }
    }
    # print Data::Dumper->Dump([\@functional_recipe_lines],['commands']);
    LINE:
    for my  $line (@processed_recipe_lines)
    {
        #
        # Removes commented lines and empty ones before the start of the recipe command
        #
        unless ($written)
        {
            next if $line =~ /^\s*#/;
            next if $line =~ /^\s*$/;
        }
        $written =1;

        #
        # While we fill the recipe, we also collect information that we will
        # then use for other tasks, such as testing or uninstalling the cluster
        #
        if ($line =~ /\s+\$(DS_NAME\w*)/)
        {
            $current_ds = $user_values{$1};
            unless ( $current_ds)
            {
                die "error parsing current dataservice name ($line)\n";
            }
        }

        #if ($line =~ /dataservice-relay-/)
        #{
        #    # 
        #    # This is the tricky part.
        #    # Relay is defined within a multi-line command.
        #    # Within this compound command, a master definition becomes a relay
        #    #
        #    $relay_next = 1;
        #}
        if ($line =~ /(members|dataservice-hosts)\s*=\s*([^\$]\S+)\s*/)
        {
            my $op=$1;
            my $list = $2;
            my ($label, $value) = get_members( \%user_values, $op, $list, $master_count, 'SLAVES');
            #print "<$label $value>\n";
            $user_values{$label} = $value;
            my $master_label = 'MASTER';
            if ($label =~ /\s+(\d+)$/)
            {
                $master_label ="MASTER$1";
            }
            $line ="--$op=\$master_label,\$$label";
            #print "+++$line\n";
            if ($label eq 'SLAVES1')
            {
                $user_values{SLAVES} = $value;
            }
            #print "after members - ", Dumper \%user_values;
        }
        if ($line =~ /((?:dataservice-)?connectors)\s*=\s*([^\$]\S+)\s*/)
        {
            my $op=$1;
            my $list = $2;
            my ($label, $value) = get_members( \%user_values, $op, $list, 0, 'CONNECTORS');
            #print "<$label $value>\n";
            $user_values{$label} = $value;
            $line ="--$op=\$$label";
            if ($label eq 'CONNECTORS1')
            {
                $user_values{CONNECTORS} = $value;
            }
            #print "after connectors - ", Dumper \%user_values;
        }
        if ($line =~ /(?:master|dataservice-master-host)=\$\{?(\w+)\}?/)
        {
             my $master_definition = $1;
             if ($relay_masters{$master_definition})
             {
                 push @{ $cluster_info{relays} }, $master_definition; 
                 push @{ $deployment_info{$current_ds}{relays} }, $user_values{$master_definition}; 
             }
             else
             {
                push @{ $cluster_info{masters} }, $master_definition; 
                push @{ $deployment_info{$current_ds}{masters} }, $user_values{$master_definition}; 
             }
        }
        elsif ($line =~ /(?:members|dataservice-hosts)\s*=\s*\$\{?(\w+)\}?,\$\{?(\w+)\}?/)
        {
             my $slaves = $user_values{$2};
             my $slaves_identifier = $2;
             #remove spaces
             $slaves =~ s/\s*//g;
             push @{ $cluster_info{slaves} }, $slaves_identifier; 
             push @{ $deployment_info{$current_ds}{slaves} }, split( /,/, $slaves);
        }
        elsif ($line =~ /(?:dataservice-)?connectors\s*=\s*\$\{?(\w+)\}?/)
        {
             my $connectors = $user_values{$1};
             my $connectors_identifier = $1;
             #remove spaces
             $connectors =~ s/\s*//g;
             push @{ $cluster_info{connectors} }, $connectors_identifier; 
             push @{ $deployment_info{$current_ds}{connectors} }, split(/,/, $connectors); 
        }
        elsif ($line =~ /connector-r([ow])-addresses\s*=\s*\$\{?(\w+)\}?/)
        {
            # print "##$2\n";
             if ($user_values{$2})
             {
                push @{ $cluster_info{"connectors_r$1"} }, $2; 
                if ($current_ds)
                {
                    push @{ $deployment_info{$current_ds}{"connectors_r$1"} }, $user_values{$2}; 
                }
                else
                {
                    push @{ $deployment_info{_all_ds_}{"connectors_r$1"} }, $user_values{$2}; 
                }
             }
        }
        elsif ($line =~ /\$(COMPOSITE_DS)/)
        {
            $deployment_info{composite_ds}=$user_values{$1};
        }
        elsif ($line =~ /connector-smartscale\s*=\s*\$?\{?(\w+)\}?/)
        {
            $cluster_info{smartscale}=$1;
        }
        #
        # before the variable replacement, we check that all variables are covered
        #
        while ($line =~ /\${?(\w+)}?/g)
        {
            my $key = $1;
            unless (exists $user_values{$key})
            {
                #
                # If a variable is defined in the user values, then we replace it.
                #
                # If it is not defined, the default behavior is to SKIP THE LINE.
                # However, if we say '--fail-on-undefined', the program dies.
                #
                if (exists $ENV{$key})
                {
                    $user_values{$key} = $ENV{$key};
                }
                else
                {
                    if ($options->{skip_vars} && $options->{skip_vars}{$key})
                    {
                        push @skipped, $line;
                        next LINE;
                    }
                    elsif ($options->{fail_on_undefined})
                    {
                        die "undefined variable '$key' in $options->{template}\n";
                    }
                    else
                    {
                        push @skipped, $line;
                        next LINE;
                    }
                } 
            }
        }

        #
        # This is the actual replacement of the variables.
        # We can do it because, at this point, we know that
        # all the variables are either defined or skipped.
        #
        for my $key (keys %user_values)
        {
            # print "[$key] <$line>\n";
            $line =~ s/\${?$key\b}?/$user_values{$key}/g;
        }
        $recipe_text .= $line;

        # print '>>>  ', $line, '+++', Dumper( \%deployment_info), '--- ', $current_ds || '', "\n";
    }

    #### $recipe_text =~ s/--/\\\n\t--/g;

    #
    # If verbose output was requested, we also list the skipped lines
    #
    if (@skipped && $options->{verbose})
    {
        $recipe_text .= "\n\n";
        for my $s (@skipped)
        {
            $recipe_text .= "# [SKIPPED] $s"
        }
    }
    if ($user_values{MORE_OPTIONS} && $user_values{MORE_OPTIONS} =~ /connector-smartscale\s*=\s*(\w+)?/)
    {
        $cluster_info{smartscale}=$1;
    }
    #
    # We define a detailed server list
    #
    my %server_list = (
        masters => [], 
        slaves => [], 
        connectors => [], 
        connectors_ro => [], 
        connectors_rw => [], 
        relays => []);
    for my $key (keys %server_list)
    {
        for my $item (@{ $cluster_info{$key} })
        {
            my @members = split /,/, $user_values{$item};
            for my $member (sort @members)
            {
                # print ">> $key -- $member \n";
                push @{ $server_list{$key} }, $member;
            }
        }
    }
    # print Dumper \%deployment_info;
    for my $key (keys %deployment_info)
    {
        next unless (ref $deployment_info{$key} && (ref($deployment_info{$key}) eq 'HASH'));
        for my $item ( keys %{$deployment_info{$key} })
        {
            my @sorted_members = sort @{$deployment_info{$key}{$item}};
            $deployment_info{$key}{$item} = [@sorted_members];
        }
    }
    if ($deployment_info{_all_ds_})
    {
        # print Dumper \%deployment_info; exit;
        for my $ds (keys %deployment_info)
        {
            next if $ds eq '_all_ds_';
            for my $item (keys %{$deployment_info{_all_ds_}})
            {
                $deployment_info{$ds}{$item} = [@{ $deployment_info{_all_ds_}{$item} } ];
            }
        }
        delete $deployment_info{_all_ds_}; 
    } 
    my %mysql_error_logs;
    my @all_hosts;
    my %seen_hosts;
    for my $wanted (keys %server_list)
    {
        next unless $wanted =~/^(?:masters|relays|slaves)$/;
        for my $host (@{ $server_list{$wanted}})
        {
            unless ($seen_hosts{$host})
            {
                push @all_hosts, $host;
                $seen_hosts{$host}++;
            }
        }
    }
    for my $server (@all_hosts)
    {
        check_for_running_mysql_server($server, \%user_values);
    }
    for my $server (@all_hosts)
    {
        my $MYSQL = sprintf("mysql -h %s -u %s -p%s -P %d",
        $server ,
        $user_values{DATASOURCE_USER},
        $user_values{DATASOURCE_PASSWORD},
        $user_values{DATASOURCE_PORT});
        my $error_log = get_local_result("$MYSQL -BN -e 'show variables' | grep log_error");
        if ($error_log)
        {
            $error_log =~ s/\w+\s+//;
            $mysql_error_logs{$server}= $error_log;
        }
        else
        {
            warn "$server: can't determine where MySQL error log is \n";
        }
    }
    for my $key (keys %user_values)
    {
        my $value = $user_values{$key};
        if ($value eq 'autodetect')
        {
            if (my $expanded_value=resolve_autodetect(\%user_values,$key))
            {
                if ($CLI_Utils::VERBOSE)
                {
                    print "# In key '\$$key': replaced 'autodetect' with '$expanded_value'\n" ;
                }
                $user_values{$key} = $expanded_value;
            }
            else
            {
                die "Could not find an auto detected value for '$key'\n";
            }
        }
    }

    #
    # Before returning, we add the metadata to the {options} object.
    #
    $options->{user_values} = \%user_values;
    $options->{cluster_info} = \%cluster_info;
    $options->{server_list} = \%server_list;
    $options->{deployment_info} = \%deployment_info;
    $options->{mysql_error_logs} = \%mysql_error_logs;
    my $all_needed_accounted_for=1;
    for my $needed (qw(masters slaves connectors))
    {
        unless (@{ $server_list{$needed}})
        {
            $all_needed_accounted_for=0;
            warn "Missing needed component ($needed)\n";
        }
    }
    unless ($all_needed_accounted_for)
    {
        print Data::Dumper->Dump([\%server_list],['server_list']);
        die "Can't continue without all needed components\n";
    }
    if ($CLI_Utils::DEBUG)
    {
        $Data::Dumper::Indent=1;
        print Data::Dumper->Dump([$options],['options']);
    }
    $current_options = $options;
    $options->{current_hostname_used}=0;
    # print Dumper \%deployment_info;
    CHECK_HOSTNAME_IN_CONNECTORS:
    for my $ds ( keys %deployment_info)
    {
        if (ref($deployment_info{$ds}) && $deployment_info{$ds}->{connectors})
        {
            for my $connector (@{$deployment_info{$ds}->{connectors}})
            {
                if ($connector eq $install_server_hostname)
                {
                    $options->{current_hostname_used} =1;
                    last CHECK_HOSTNAME_IN_CONNECTORS; 
                }
            
            }
        }
    }
    unless ($options->{current_hostname_used})
    {
        warn "Tungsten-cookbook tests must run from a server where you install a connector\n";
        warn "You can run the installation, but not the tests\n" 
    }
    return $recipe_text;
}
sub remote_file_test
{
    my ($server,$file,$test) = @_;
    my $test_ok = get_remote_result($server, "if [ $test $file ] ; then echo OK ; else echo no; fi");
    return defined($test_ok) && ($test_ok eq 'OK');
}

sub resolve_autodetect
{
    my ($user_values, $key) = @_;
    my %known_keys = (
        MYSQL_CONF                  => [ 'file',   ['/etc/my.cnf', '/etc/mysql/my.cnf'] ],
        DB_VERSION                  => [ 'query',  ['select version()']],
        DATASOURCE_BOOT_SCRIPT      => [ 'exec',   ['/etc/init.d/mysql', '/etc/init.d/mysqld'], ],
        MYSQL_BINARY_LOG_DIRECTORY  => [ 'dir'  ,  ['/var/lib/mysql', '/usr/local/mysql/data'], ],
        # DATASOURCE_PORT             => [ 'default',[ '3306']],
    );
    unless (exists $known_keys{$key})
    {
        warn "No known resolution for key '$key'\n";
        return 0;
    }
    my $master = $user_values->{MASTER};
    $master = $user_values->{MASTER1} unless $master;
    die "Can't find a suitable server to test autodetected key $key\n" unless $master;

    my $detector = $known_keys{$key};
    if (2 < @{$detector})
    {
        die "error in detector record definition for key '$key'. Only one item is allowed.\n";
    }
    my ($detector_type)  = $detector->[0];
    my $candidate_values = $detector->[1];
    if ($detector_type eq 'file')
    {
        for my $file (@{ $candidate_values })
        {
            if ( remote_file_test( $master, $file, '-f'))
            {
                return $file;
            }
        }
    }
    elsif ($detector_type eq 'exec')
    {
        for my $file (@{ $candidate_values })
        {
            if ( remote_file_test( $master, $file, '-e'))
            {
                return $file;
            }
        }
    }
    elsif ($detector_type eq 'dir')
    {
        for my $dir (@{ $candidate_values })
        {
            if ( remote_file_test( $master, $dir, '-d'))
            {
                return $dir;
            }
        }
    }
    elsif ($detector_type eq 'query')
    {
        my $MYSQL = sprintf("mysql -h %s -u %s -p%s -P %d",
            $master,
            $user_values->{APPLICATION_USER},
            $user_values->{APPLICATION_PASSWORD},
            $user_values->{DATASOURCE_PORT});
        for my $query (@{ $candidate_values })
        {
            my $version = get_local_result("$MYSQL -BN -e '$query'" );
            return 0 unless $version;
            if ($version && ($version =~ /(\d+\.\d\.\d+)/))
            {
                return $1;
            }
        }
    }
    return 0;
}

sub start_load
{
    my ($options) = @_;
    my $evaluator_pid = start_evaluator($options);
    if ($evaluator_pid)
    {
        if ($CLI_Utils::VERBOSE) 
        {
            my $tmpdir= write_to_tmp(undef,undef);
            print "# Evaluator started with pid $evaluator_pid\n"; 
            print "# Evaluator output can be monitored at $tmpdir/evaluator.log\n"; 
        }
    }
    else
    {
        return;
    }
}

######################################################
#
# Runs the test on an installed recipe
#
######################################################
sub run_test
{
    my ($options) = @_;
    my $user_values = $options->{user_values};
    my $cluster_info = $options->{cluster_info};
    my $server_list = $options->{server_list};
    my $deployment_info = $options->{deployment_info};
    unless ($user_values && $cluster_info && $server_list)
    {
        die "Before calling 'run_test', metadata should be collected using 'fill_template'\n";
    }
    unless ($options->{current_hostname_used})
    {
        warn "Running this test requires a connector in the current host.\n";
        exit 1;
    }
    if ($options->{start_load})
    {
        start_load($options);
    }
    if ($CLI_Utils::VERBOSE) 
    {
        # print Data::Dumper->Dump([ $server_list], ['server_list']);
        my %info ;
        my $cds;
        if ($deployment_info->{composite_ds})
        {
            $cds = $deployment_info->{composite_ds};
            $info{$cds} ={};
        }
        for my $key (keys %{ $deployment_info })
        {
            next if $key eq 'composite_ds';
            if ($cds)
            {
                $info{$cds}{$key} = $deployment_info->{$key};
            }
            else
            {
                $info{$key} = $deployment_info->{$key};
            }
        }
        my $deployment_info;
        eval "use YAML";
        if ($@)
        {
            $Data::Dumper::Indent=1;
            # print Data::Dumper->Dump([ \%info], ['deployment_info']);
            $deployment_info= Data::Dumper->Dump([ \%info], ['deployment_info']);
        }
        else
        {
            # print Dump(\%info);
            $deployment_info= Dump(\%info);
        }
        $deployment_info =~ s/^/#/gm;
        print $deployment_info;
    }
    #
    # Performs simple tests on each server
    #
    my $test_result = 0;
    #
    # The value of $test_result will be increased by the result of each test.
    # The desired final value is '0' (meaning: no failures)
    #
    for my $server (@{ $server_list->{masters} })
    {
        $test_result += test_server($server, 'master', $user_values); 
        # print "# test_server master $test_result\n" if $CLI_Utils::VERBOSE;
    }
    for my $server (@{ $server_list->{slaves} })
    {
        $test_result += test_server($server, 'slave', $user_values); 
        # print "# test_server slave  $test_result\n" if $CLI_Utils::VERBOSE;
    }
    for my $server (@{ $server_list->{relays} })
    {
        $test_result += test_server($server, 'relay', $user_values); 
        # print "# test_server relay  $test_result\n" if $CLI_Utils::VERBOSE;
    }
    for my $server (@{ $server_list->{connectors} })
    {
        $test_result += test_connector($options,$server, $options->{cluster_info}{smartscale} || 'false', $user_values); 
        # print "# test_connector smartscale  $test_result\n" if $CLI_Utils::VERBOSE;
    }
    for my $server (@{ $server_list->{connectors_rw} })
    {
        $test_result += test_direct_connector($options,$server, 'master', $user_values); 
        # print "# test_direct_connector master  $test_result\n" if $CLI_Utils::VERBOSE;
    }
    for my $server (@{ $server_list->{connectors_ro} })
    {
        $test_result += test_direct_connector($options,$server, 'slave', $user_values); 
        # print "# test_direct_connector slave  $test_result\n" if $CLI_Utils::VERBOSE;
    }
    if ($deployment_info->{composite_ds})
    {
        $test_result += test_composite_dataservice($options,$deployment_info, $user_values); 
        # print "# test_composite_dataservice $test_result\n" if $CLI_Utils::VERBOSE;
    }
    # print Dumper $test_result;
    test_summary($options, $test_result) if $test_result;
    if ($options->{demo})
    {
        $demoing = 1;
    }
    $SIG{INT} = \&catch_sysint;
    if ($options->{demo_delay})
    {
        $demo_delay = $options->{demo_delay};
        $demoing = 1;
    }
    if ($options->{backup_first})
    {
        print "# taking a backup before starting extended tests \n" if $CLI_Utils::VERBOSE;
        print_log( "# taking a backup before starting extended tests \n",1);
        $test_result += backup_and_restore(undef, $options, $user_values);
        test_summary($options, $test_result) if $test_result;
    }

    if ($options->{tests} && $options->{tests}{replication})
    {
        local $demoing =0;
        print "# replication test \n" if $CLI_Utils::VERBOSE;
        print_log( "# replication test \n",1);
        $test_result += test_replication($options, $server_list, $user_values);
    }


    for my $ds (keys %{ $deployment_info })
    {
        test_summary($options, $test_result) if $test_result;
        next if $ds eq 'composite_ds';
        my $main_role = 'master';
        my $master = $deployment_info->{$ds}{masters}[0];
        unless ($master)
        {
            $master = $deployment_info->{$ds}{relays}[0];
            $main_role = 'relay';
        }
        my $slave = $deployment_info->{$ds}{slaves}[0];

        if ($options->{tests} && $options->{tests}{switch})
        {
            print "# ($ds) switch \n" if $CLI_Utils::VERBOSE;
            print_log( "# ($ds) switch \n", 1);
            $test_result += test_switch($options,$master, $slave, $user_values );
            test_summary($options, $test_result) if $test_result;
            $test_result += test_switch($options,$slave, $master, $user_values );
            test_summary($options, $test_result) if $test_result;
        }
        if ($options->{tests} && $options->{tests}{failover})
        {
            my @policies_for_failover_test = qw(automatic maintenance);
            if ($tungsten_version < 2)
            {
                @policies_for_failover_test = qw(automatic);
            }
            for my $policy_mode (@policies_for_failover_test)
            {
                print "# ($ds) failover in $policy_mode mode \n" if $CLI_Utils::VERBOSE;
                print_log( "# ($ds) failover in $policy_mode mode \n",1);
                $test_result += test_failover($options,$master, $slave, $user_values , $main_role, $policy_mode);
                test_summary($options, $test_result) if $test_result;
                if ($deployment_info->{composite_ds} && ($main_role eq 'master' ) && ! $test_result )
                {    
                    $test_result += test_after_failover($options,$deployment_info, $user_values );
                    test_summary($options, $test_result) if $test_result;
                }
                if ($options->{tests}{recover} && (! $test_result))
                {
                    print "# ($ds) recovery \n" if $CLI_Utils::VERBOSE;
                    print_log( "# ($ds) recovery \n", 1);
                    sleep 1;
                    $test_result += test_recover($master, $options, $user_values); 
                    test_summary($options, $test_result) if $test_result;
                    $test_result += test_switch($options,$slave, $master, $user_values );
                    test_summary($options, $test_result) if $test_result;
                }
            }
        }
    }
    if ($deployment_info->{composite_ds} && ! $test_result )
    {
        if ($options->{tests} && $options->{tests}{cswitch})
        {
            print "# composite switch \n" if $CLI_Utils::VERBOSE;
            print_log( "# composite switch \n" ,1);
            $test_result += test_composite_switch($options,$deployment_info, $user_values); 
        }
        if ($options->{tests} && $options->{tests}{cfailover} && ! $test_result)
        {

            print "# composite failover \n" if $CLI_Utils::VERBOSE;
            print_log( "# composite failover \n",1);
            my ($old_ds_master, $old_master) = test_composite_failover($options,$deployment_info, $user_values); 
            unless ($old_master && $old_ds_master)
            {
                print "# Something is wrong: ", Dumper $old_ds_master, $old_master;
                $test_result++;
            }
            test_summary($options, $test_result) if $test_result;
            if ($options->{tests}{crecover})
            {
                print "# composite recovery \n" if $CLI_Utils::VERBOSE;
                print_log( "# composite recovery \n" , 1);
                $test_result += test_composite_recovery($deployment_info, $user_values,$old_ds_master, $old_master, $options); 
                test_summary($options, $test_result) if $test_result;
                $test_result += test_composite_switch($options,$deployment_info,$user_values, $old_ds_master);
            }
        }
    }
    if ($options->{tests}{'contents'})
    {
        my $save_demoing=$demoing;
        $demoing=0;
        print "# check contents \n" if $CLI_Utils::VERBOSE;
        print_log( "# check contents \n" , 1);
        stop_load();
        $options->{stop_load_at_end} = 0;
        sleep 2;
        $test_result += test_table_contents($options);
        $demoing=$save_demoing;
    }
    test_summary( $options, $test_result);
}

sub test_summary
{
    my ($options,$exit_code) = @_;
    printf   "#tests: %5d\n" 
           . "#pass : %5d (%4.0f%%)\n"
           . "#fail : %5d (%4.0f%%)\n",
            $test_outcome{all}, 
            $test_outcome{pass}, 
            $test_outcome{pass} / $test_outcome{all} * 100,
            $test_outcome{fail} ,
            $test_outcome{fail} / $test_outcome{all} * 100
            ;
    if ($options->{collect_logs})
    {
        collect_logs($options);
    }

    if ($options->{cluster_status})
    {
        print get_cluster_status($options);
    }
    if ($options->{stop_load_at_end})
    {
        stop_load();
    }
    exit $exit_code;
}


sub run_cctrl
{
    my ($server, $args, $command) = @_;
    my $options = $current_options;
    my $user_values = $options->{user_values};
    unless ($user_values )
    {
        die "Before calling 'run_cctrl', metadata should be collected using 'fill_template'\n";
    }
    my $cctrl = get_cctrl($user_values);
    my $result  = get_remote_result($server, "echo '$command' | $cctrl $args");
    print $result;
}



sub get_cluster_status
{
    my ($options, $log_status) = @_;
    my $deployment_info = $options->{deployment_info};
    my $user_values = $options->{user_values};
    unless ($user_values && $deployment_info)
    {
        die "Before calling 'get_cluster_status', metadata should be collected using 'fill_template'\n";
    }
    if ($log_status)
    {
        $options->{verbose} = 0;
    }
    my $composite = defined($deployment_info->{composite_ds});
    my $cctrl = get_cctrl($user_values);
    my $master;
    $cctrl .= ' -expert' ;
    if ($composite)
    {
        $cctrl .= ' -multi'; 
    }
    my $status = '';
    # print Dumper $deployment_info;
    my $cmd = 'ls';
    if ($options->{verbose} )
    {
        $cmd .= ' -l';
    }   
    for my $ds (keys %{ $deployment_info })
    {
        next if $ds eq 'composite_ds';
        my $prefix='';
        if ($composite)
        {
            $prefix = "use $ds; "
        }
        my $server = $deployment_info->{$ds}{masters}[0] ;
        if ($server)
        {
           $master = $server;
        } 
        else
        {
            $server = $deployment_info->{$ds}{relays}[0];
        }
        unless ($server)
        {
            die "could not find a master or a relay for $ds\n";
        }
        my $ds_status  = get_remote_result($server, "echo '$prefix $cmd' | $cctrl");
        if ($ds_status)
        {
            $status .= $ds_status ."\n";
        }
        for my $command (('members','ls resources', 'router * status'))
        {
            $ds_status  = get_remote_result($server, "echo '$prefix $command' | $cctrl");
            if ($ds_status)
            {
                $status .= $ds_status ."\n";
            }
        }
    }
    if ($composite)
    {
        my $composite_status = get_remote_result($master, "echo 'use $deployment_info->{composite_ds}; $cmd' | $cctrl");
        if ($composite_status)
        {
            $status .= $composite_status ."\n";
        }
    }
    if ($log_status)
    {
        print_log("# (cluster status)\n" .$status ."#\n#\n",0);
        return;
    }
    return $status;
}

sub collect_logs
{
    my ($options) = @_;
    my $user_values = $options->{user_values};
    my $cluster_info = $options->{cluster_info};
    my $server_list  = $options->{server_list};
    unless ($user_values && $cluster_info && $server_list)
    {
        die "Before calling 'collect_logs', metadata should be collected using 'fill_template'\n";
    }
    my $all_tools =1;
    for my $program (qw(tar scp gzip))
    {
        my $program = CLI_Utils::which($program);
        unless ($program)
        {
            $all_tools =0;
            warn "Could not find $program in \$PATH \n";
        }
    }
    unless ($all_tools)
    {
        warn "Can't collect logs without the above programs \n"; 
        return;   
    }

    my %servers ;
    for my $list (keys %{ $server_list })
    {
        next unless ref($server_list->{$list}) && (ref($server_list->{$list}) eq 'ARRAY');
        for my $server (@{ $server_list->{$list}})
        {
            my $ip = CLI_Utils::resolveip($server);
            unless ($ip =~ /^127\.0\.0\./)
            {
                $servers{$server}++;
            }
        }
    }
    my $tmp_dir = get_temp_name(); 
    if ($options->{logs_store_name})
    {
        $tmp_dir = $options->{logs_store_name};
    }
    my %store_docs =
    (
        executables => 
        {
            manager     => "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-manager/bin/manager",
            replicator  => "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-replicator/bin/replicator",
            connector   => "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-connector/bin/connector",
        },
        conf => 
        {
            tungsten    => "$user_values->{CONTINUENT_ROOT}/conf/tungsten.cfg",
            manager     => "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-manager/conf/*.properties",
            cluster     => "$user_values->{CONTINUENT_ROOT}/tungsten/cluster-home/conf/",
            replicator  => "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-replicator/conf/*.properties",
            connector   => "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-connector/conf/*.{properties,map}",
            mysql       => "$user_values->{MYSQL_CONF}",
        },
        log => 
        {
            replicator  => "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-replicator/log/*.log",
            connector   => "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-connector/log/*.log",
            manager     => "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-manager/log/*.log",
            mysql       => $options->{mysql_error_logs},
        },
        cookbook =>
        {
            conf     => './{deploy.cfg,current_recipe.sh,cookbook/tungsten-cookbook-command-line.history}',
            recipes  => './cookbook/*.{tmpl,sh}',
            log      => '*.log',
        }
    );
    
    my $result =mkdir $tmp_dir;
    unless ($result)
    {
        warn "Could not create '$tmp_dir' ($!)\n";
        warn "No logs were saved\n";
        return;
    }
    my %seen;
    for my $server (keys %servers)
    {
        my $server_dir=$server;
        $server_dir =~ s/\W/_/g;
        mkdir "$tmp_dir/$server_dir";
        for my $section (qw(log conf cookbook))
        {
            mkdir "$tmp_dir/$server_dir/$section";
        }
        for my $section (qw(log conf))
        {
            for my $tool (keys %{$store_docs{$section}} )
            {
                if ($store_docs{executables}{$tool} && ($section eq 'log') )
                {
                    # print qq($server, "$store_docs{executables}{$tool} dump"\n);
                    get_remote_result($server, "$store_docs{executables}{$tool} dump");
                }
                mkdir "$tmp_dir/$server_dir/$section/$tool";
                my $filename = $store_docs{$section}{$tool} ;
                if (ref( $filename)  && (ref($filename) eq 'HASH') && $filename->{$server})
                {
                    $filename = $filename->{$server};
                    my $new_filename = '/tmp/mysql_error.log';
                    get_remote_result($server, "sudo cp $filename $new_filename");
                    get_remote_result($server, "sudo chown tungsten $new_filename");
                    $filename = $new_filename;
                }
                elsif (ref $filename)
                {
                    # we don't have a record for this server. Probably because it's a connector
                    next;
                }
                if (($filename !~ /\*/) && remote_file_test( $server,$filename , '-d'))
                {
                    $filename =~ s{/$}{};
                    get_remote_result($server, "cd $filename; tar -c . | gzip -c > ../properties.bundle.tar.gz; mv ../properties.bundle.tar.gz .");
                    get_local_result( "$SCP -q $SSH_USER\@$server:$filename/properties.bundle.tar.gz $tmp_dir/$server_dir/$section/$tool");
                    get_remote_result($server, "rm -f $filename/properties.bundle.tar.gz");
                }
                else
                {
                    my $file_exists = get_remote_result($server , "ls $filename 2>/dev/null | wc -l");
                    if ($file_exists && ($file_exists ge '0'))
                    {
                        get_local_result( "$SCP -q $SSH_USER\@$server:$filename $tmp_dir/$server_dir/$section/$tool");
                    }
                }
            }
        }
    }
    mkdir "$tmp_dir/cookbook";
    for my $doc (keys %{ $store_docs{cookbook}})
    {
        get_local_result( "cp $store_docs{cookbook}{$doc} $tmp_dir/cookbook/ ");
    }
    open my $CS, '>', "$tmp_dir/cookbook/cluster_status"
        or die "can't write to $tmp_dir/cookbook/cluster status\n";
    print $CS get_cluster_status($options);
    close $CS;
    my $tarball= "$tmp_dir.tar.gz";
    get_local_result ("tar -c $tmp_dir | gzip -c > $tarball");
    system "rm -rf $tmp_dir";
    print "Logs collected in $tarball\n";
    if ($options->{logs_store_dir})
    {
        if (-d $options->{logs_store_dir})
        {
            my $result = get_local_result("cp $tarball $options->{logs_store_dir}") ;
            unless ($result)
            {
                print "'$tarball' stored in $options->{logs_store_dir}\n";
            }
        }
        else
        {
            warn "directory $options->{logs_store_dir} not found, or not a directory\n";
        }
    }
    if ($options->{logs_s3_bucket})
    {
        unless (CLI_Utils::which('aws'))
        {
            die "could not find 'aws'\n";
        }
        my $result = get_local_result("aws put $options->{logs_s3_bucket} $tarball") ;
        if ($result)
        {
            print "$result\n";
        }
        else
        {
            print "'$tarball' saved to $options->{logs_s3_bucket}\n";
        }
    }
}

sub get_timestamp
{
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =localtime;
    $year += 1900;
    $mon++;
    return sprintf('%4d_%02d_%02d_%02d_%02d_%02d',
            $year, $mon, $mday, $hour, $min, $sec);
}

sub get_temp_name
{
   return "TC" . get_timestamp() ;
}

sub get_loads
{
    my ($options, $servers) = @_;
    my %loads;
    for my $server (@$servers)
    {
        my $ds = get_datasource($options, $server, 'composite');
        if ($tungsten_version > 1)
        {
            $TUNGSTEN_SCHEMA = 'tungsten_' . $ds;
        }
        else
        {
            $TUNGSTEN_SCHEMA = 'tungsten';
        }
        my $MYSQL = sprintf("mysql -h %s -u %s -p%s -P %d",
            $server,
            $options->{user_values}{APPLICATION_USER},
            $options->{user_values}{APPLICATION_PASSWORD},
            $options->{user_values}{DATASOURCE_PORT});
        my $seqno = get_local_result("$MYSQL -BN -e 'select max(seqno) from $TUNGSTEN_SCHEMA.trep_commit_seqno'");
        if ($seqno)
        {
            $loads{$server} = $seqno;
        }
    }
    return \%loads;
}

sub compare_loads
{
    my ($first, $second) = @_;
    my $smallest_delta =-1;
    my $largest_delta = 0;
    for my $server (keys %{ $first})
    {
        if ($second->{$server} && $second->{$server} > $first->{$server})
        {
            my $delta = $second->{$server} - $first->{$server};
            if ($smallest_delta < 0)
            {
                $smallest_delta = $delta;
            }
            if ($smallest_delta < $delta)
            {
                $smallest_delta = $delta;
            }
            if ($delta > $largest_delta)
            {
                $largest_delta = $delta;
            }
        } 
    }
    if (wantarray)
    {
        return ($smallest_delta, $largest_delta);
    }
    else
    {
        return $largest_delta;
    }
}

sub is_loaded
{
    my ($options) = @_;
    my $user_values = $options->{user_values};
    my $server_list  = $options->{server_list};
    my @servers ;
    for my $list (qw(masters relays slaves))
    {
        next unless ref($server_list->{$list}) && (ref($server_list->{$list}) eq 'ARRAY');
        for my $server (@{ $server_list->{$list}})
        {
            push @servers, $server;      
        } 
    }
    my $initial_server_loads = get_loads($options, \@servers);
    sleep 1;
    my $second_server_loads = get_loads($options, \@servers);
    # print Dumper $initial_server_loads, $second_server_loads;
    my $delta = compare_loads($initial_server_loads, $second_server_loads);
    # print "$delta\n";
    return $delta;
 }


#######################################################
# run recipe
#
# Dumps the recipe text into a shell script and runs it
#
#######################################################
sub run_recipe 
{
    my ($options) = @_;
    my $recipe = fill_template($cli->{options});
    my $master = $options->{server_list}{masters}[0];
    my $already_installed = remote_file_test( $master, "$options->{user_values}{CONTINUENT_ROOT}/tungsten/cluster-home/bin/startall", '-x' );
    if ($already_installed)
    # if ( -x "$options->{user_values}{CONTINUENT_ROOT}/tungsten/cluster-home/bin/startall")
    {
        warn "# cluster already installed in $cli->{options}{user_values}{CONTINUENT_ROOT}\n";
        return;    
    }
    my $current_recipe = abs_path("current_recipe.sh");
    open my $FH, '>', $current_recipe
        or die "can't open $current_recipe";
    print $FH "#!/bin/bash\n";
    if ($CLI_Utils::VERBOSE )
    {
        print $FH "\nset -x\n\n";
    }
    print $FH $recipe;
    close $FH;
    chmod 0755, $current_recipe;

    #
    # Creates the uninstall file for manual usage
    #
    uninstall_cluster($options,"just prepare");
    #
    # Before running the recipe, cleans 'deploy.cfg' from the directory
    #
    clean_deployment();
    my $command = $current_recipe;
    if ($options->{dry_run})
    {
        $command = "cat $current_recipe";
    }
    # This function checks the system for a previous deployment, and remove it if found
    check_for_previous_deployment();
    if ($CLI_Utils::VERBOSE && !$options->{dry_run})
    {
        print $recipe,"\n";
    }
    my $result = system( $command );
    if ($result)
    {
        die "error running '$command'\n";
    }
    exit if $options->{dry_run};
    if (( !$options->{no_shortcuts}) && ($options->{user_values}{CONTINUENT_ROOT} ne $ENV{HOME}))
    {
        set_shortcuts($options);
    }
}

sub check_for_previous_deployment
{
    #
    # This is an extremely dangerous check. It will check if there is an existing installation and remove it
    #
    # Since this option is only useful for testing environments,
    # it will not run unless we have explicitly set I_WANT_TO_UNINSTALL
    #
    return unless $ENV{I_WANT_TO_UNINSTALL};
    my $deployment_file = "$ENV{HOME}/$continuent_tungsten_staging_directory";
    # print " $deployment_file\n";
    if ( -f $deployment_file)
    {
        my @lines = CLI_Utils::slurp($deployment_file);
        my $staging_directory = '';
        for my $line (@lines)
        {
            if ($line =~ /^Staging directory\s*:\s*(\S+)/)
            {
                $staging_directory =$1;
                last;
            }
        }
        if ($staging_directory && (-d $staging_directory))
        {
            my $curdir= qx(pwd);
            chomp $curdir;
            chdir $staging_directory;
            print "# Found a previous installation. Attempting uninstall\n" if $CLI_Utils::VERBOSE;
            my $uninstall_script = './cookbook/current_recipe_uninstall.sh';
            if ( -x $uninstall_script)
            {
                system $uninstall_script;
            }
            chdir $curdir;
        }
    }
}


sub check_for_running_mysql_server
{
    my ($server, $user_values) = @_;
    my $boot_script=$user_values->{DATASOURCE_BOOT_SCRIPT};
    if ($boot_script eq 'autodetect')
    {
        $boot_script = '/etc/init.d/mysql';
    }

    print "# checking for $boot_script in server $server\n" if $CLI_Utils::VERBOSE > 1;
    my $boot_script_exists = remote_file_test($server, $boot_script, '-x');
    unless ($boot_script_exists)
    {
        $boot_script = '/etc/init.d/mysqld';
        print "# checking for $boot_script in server $server\n" if $CLI_Utils::VERBOSE > 1;
        $boot_script_exists = remote_file_test($server, $boot_script, '-x');
    }
    unless ($boot_script_exists)
    {
        die "Can't find mysql boot script for server $server\n";
    }
    my $mysql_socket= get_remote_result($server, "grep '^\\s*socket' /etc/my.cnf |head -n 1");
    if ($mysql_socket && ($mysql_socket =~ /^\s*socket\s*=\s*(\S+)/))
    {
        $mysql_socket = $1; 
    }
    else
    {
        #
        # let's try some defaults
        #
        $mysql_socket = undef;
        for my $try (('/tmp/mysql.sock', '/var/lib/mysql/mysql.sock'))
        {
            if (remote_file_test($server, $try, '-e'))
            {
                $mysql_socket = $try;
                last;
            }
        }
        unless ($mysql_socket)
        {
            die "Unable to determine socket file for server $server\n";
        }
    }
    
    my $mysql_socket_exists = remote_file_test($server, $mysql_socket, '-e');
    unless ($mysql_socket_exists)
    {
        print "# attempting kill-all -9 on server $server\n";
        get_remote_result($server, "sudo killall -9 mysqld_safe mysqld");
    }
    my $mysql_not_running = get_remote_result($server,  "sudo $boot_script status ");
    if ($mysql_not_running && ($mysql_not_running =~ /ERROR|FAILED|not running/i))
    {
        get_remote_result($server,  "sudo $boot_script start ");
    }
}


sub set_shortcuts
{
    my ($options) = @_;
    my $server_list = $options->{server_list};
    # print Dumper $server_list;
    my $hostname = qx(hostname);
    chomp $hostname;
    my $pwd = $ENV{PWD};
    my %seen_servers;
    use POSIX qw(strftime);
    my $now_string = strftime "%Y-%m-%d %H:%M:%S", localtime;
    my $staging_dir_info=
          "Continuent Tungsten version $full_tungsten_version{major}.$full_tungsten_version{minor}.$full_tungsten_version{revision}-$full_tungsten_version{buildNumber}\n"
        . "Installed from host : $hostname\n"
        . "Staging directory   : $pwd\n" 
        . "Continuent root     : $options->{user_values}{CONTINUENT_ROOT}\n" 
        . "Template            : $options->{template}\n"
        . "Installed at        : $now_string\n"
        ;
    open my $sdi_fh, '>', $continuent_tungsten_staging_directory
        or die "can't create staging directory info file\n";
    print $sdi_fh $staging_dir_info;
    close $sdi_fh;
    for my $group (qw(masters slaves relays connectors))
    {
        for my $server ( @{ $server_list->{$group} })
        {
            next if $seen_servers{$server};
            $seen_servers{$server}++;
            if ($server eq $hostname)
            {
                get_local_result("cp $continuent_tungsten_staging_directory $ENV{HOME}/");
            }
            else
            {
                get_local_result("$SCP -q $continuent_tungsten_staging_directory $SSH_USER\@$server:");
            }
        }
    }
    for my $manager_group (qw(masters slaves relays))
    {
        for my $server ( @{ $server_list->{$manager_group} })
        {
            print "# creating manager and replicator shortcuts for $server\n" if $CLI_Utils::VERBOSE ;
            create_shortcut($options,$server, $options->{user_values}{CONTINUENT_ROOT}, [qw(manager replicator)]);
        }
    }
    for my $connector_group (qw(connectors))
    {
        for my $server ( @{ $server_list->{$connector_group} })
        {
            print "#creating connector shortcuts for $server\n" if $CLI_Utils::VERBOSE ;
            create_shortcut($options,$server, $options->{user_values}{CONTINUENT_ROOT}, [qw(connector)]);
        }
    }
    if ($CLI_Utils::VERBOSE )
    {
        print "# Tungsten installed under $options->{user_values}{CONTINUENT_ROOT}.\n";
        print "# It is also reachable at $ENV{HOME}/$options->{shortcut_dir}/ \n";
    }
}  

sub create_shortcut
{
    my ($options,$server, $continuent_root, $components) = @_;

    my $remote_script = 'set_tungsten_shortcuts.sh';
    open my $FH, '>', $remote_script
        or die "can't open $remote_script ($!)\n";
   
    my $replicator_conf = 'replicator.properties';
    if ($tungsten_version > 1)
    {
        $replicator_conf = 'static-*.properties'
    }
    my %tools_desc = (
        manager    => { 
            executables => ['cctrl', 'manager'],             
            log => 'tmsvc',   
            conf => [ 'manager.properties'], 
        },
        connector  => { executables => ['connector'],                    
            log => 'connector', 
            conf => ['connector.properties', 'user.map'],
        },
        replicator => { executables => ['trepctl', 'thl', 'replicator'], 
            log => 'trepsvc' ,  
            conf => [$replicator_conf],
        },
    );

    my $hostname = qx/hostname/;
    chomp $hostname;
    my $remote_text=<<END_REMOTE_SCRIPT;
#!/bin/bash
HOME_LINK=\$HOME/$options->{shortcut_dir}
if [ -e \$HOME_LINK ]
then
    rm -f \$HOME_LINK
fi
ln -s $continuent_root \$HOME_LINK
if [ -d \$HOME/bin ]
then
    echo "# Tungsten tools created " > \$HOME/bin/tungsten_tools_marker
    date >> \$HOME/bin/tungsten_tools_marker
    echo "# Installed from: $hostname:$ENV{PWD}" \$HOME/bin/tungsten_tools_marker
else
    exit 0
fi

END_REMOTE_SCRIPT

    print $FH $remote_text;

    for my $component (@$components)
    {
        for my $tool (@{ $tools_desc{$component}{executables} })
        {
            print $FH "\n";
            print $FH "rm -f \$HOME/bin/$tool\n";
            print $FH "echo '#!/bin/bash' > \$HOME/bin/$tool\n";
            print $FH "echo '$continuent_root/tungsten/tungsten-$component/bin/$tool \$\@' >> \$HOME/bin/$tool\n";
            print $FH "chmod +x \$HOME/bin/$tool\n";
        }
        print $FH "echo '#!/bin/bash' > \$HOME/bin/show_${component}_log\n";
        print $FH "echo 'less $continuent_root/tungsten/tungsten-$component/log/$tools_desc{$component}{log}.log' >> \$HOME/bin/show_${component}_log\n";
        print $FH "chmod +x \$HOME/bin/show_${component}_log\n";

        print $FH "echo '#!/bin/bash' > \$HOME/bin/edit_${component}_conf\n";
        my $conf_string ='';
        for my $conf (@{$tools_desc{$component}{conf}})
        {
            $conf_string .= "$continuent_root/tungsten/tungsten-$component/conf/$conf ";
        }
        my $editor = $ENV{EDITOR} || 'vim -o';
        print $FH "echo '$editor $conf_string' >> \$HOME/bin/edit_${component}_conf\n";
        print $FH "chmod +x \$HOME/bin/edit_${component}_conf\n";
    }
    close $FH;
    system "chmod +x $remote_script";
    get_local_result("$SCP -q $remote_script $SSH_USER\@$server:/tmp/");
    get_remote_result($server, "/tmp/$remote_script");
    get_remote_result($server, "rm -f /tmp/$remote_script");
    system "mv $remote_script ./cookbook/";
}


######################################################
# clean deployment
#
# Renames 'deploy.cfg' to 'deploy.cfg' + increasing
# count.
#
######################################################
sub clean_deployment
{
    my $deploy= 'deploy.cfg';
    my $count = 0;
    if ( -f $deploy)
    {
        my $new_name = $deploy;
        while ( -f $new_name)
        {
            $count++;
            $new_name = $deploy . '.' . $count;
        } 
        rename $deploy, $new_name;
    }
}


######################################################
# wait for cctrl
#
# checks for a given result in the output of a cctrl command with a timeout
#
# examples:
#  wait_for_cctrl($server, 'use world; ls', '-multi', 'composite master:ONLINE', 10);
#
######################################################
sub wait_for_cctrl
{
    my ($server, $user_values, $command, $options, $wanted, $timeout) = @_;
    my $cctrl = get_cctrl_with_options($user_values);
    my $elapsed =0;
    while ($elapsed <= $timeout)
    {
        my $cctrl_status = get_remote_result($server, "echo '$command' | $cctrl $options"); 
        # print $cctrl_status;
        if ($cctrl_status && ($cctrl_status =~ /$wanted/))
        {
            return 1
        }
        sleep 1;
        $elapsed++;
    }
    return 0;
}


sub fail_server
{
    my ($master, $slaves_list, $user_values, $main_role, $policy_mode) = @_;
    my $cctrl = get_cctrl_with_options($user_values);
    if ($CLI_Utils::VERBOSE)
    {
        print "# Failing master $master\n";
    }
    if ($policy_mode)
    {
        my $cctrl_status = get_remote_result($master, "echo 'set policy $policy_mode' | $cctrl -expert"); 
    }

    if ($fail_method eq 'mysqladmin')
    {
        unless (CLI_Utils::which('mysqladmin'))
        {
            ok(0, 'failover : could not find mysqladmin');
            return ;
        }
        my $shutdown_result = get_local_result( sprintf("mysqladmin -h %s -u %s -p%s -P %d shutdown",
              $master,
              $user_values->{'DATASOURCE_USER'},
              $user_values->{'DATASOURCE_PASSWORD'},
              $user_values->{'DATASOURCE_PORT'}));
        unless ($shutdown_result)
        {
            $shutdown_result = $?;
        }
        ok((! $shutdown_result ), 'mysqladmin shutdown succeeded' )
            or return;
    }
    elsif ($fail_method eq 'service')
    {
        my $service = '/sbin/service';
        unless (remote_file_test($master, $service, '-x'))
        {
            $service = '/usr/sbin/service';
            unless (remote_file_test($master, $service, '-x'))
            {
                custom_die("/sbin/service not found in $master");
            }
        }
        my $result = get_remote_result($master, "sudo $service mysql stop") ;
        # print "#$result\n";
    }
    else
    {
        custom_die("unrecognized fail method ($fail_method)" )
    }
    # --
    # fix for TUC-1685
    my $dataserver_result = wait_for_cctrl($master, $user_values, "ls $master", '', 'DATASERVER.state=STOPPED', 30);
    ok($dataserver_result,"Dataserver on $master went offline within 30 seconds") 
        or return;
    # --

    wait_for_input();
    if ($policy_mode && (lc($policy_mode) ne 'automatic'))
    {
        sleep 5;
        my $cctrl_status = get_remote_result($master, "echo 'set policy automatic' | $cctrl -expert"); 
    }
    
    # print Dumper $slaves_list;
    if ($main_role)
    {
        if ($CLI_Utils::VERBOSE)
        {
            print "# slaves list: (@$slaves_list)\n";
        }
        my $timeout = 60;
        my $slave = '<UNKNNOWN SLAVE>';
        my $policy_automatic = 0; 
        my $result='';
        while ($timeout > 0)
        {
            for my $master_candidate (@$slaves_list)
            {
                $result = wait_for_cctrl($master_candidate, $user_values, "ls $master_candidate", '', 'COORDINATOR.*AUTOMATIC:\w+', 5);
                print "# waiting for Policy to be AUTOMATIC (using $master_candidate) ", ($result ? 'yes' : 'no'), "\n" if $CLI_Utils::VERBOSE;
                $timeout -= 5;
                if ( $result )
                {
                    $policy_automatic =1;
                    $timeout = 0;
                    last;
                }
            }
        }
        ok(($policy_automatic), "Policy is 'AUTOMATIC' after failover") or return 1;
        $timeout = 60;
        while ($timeout > 0)
        {
            for my $master_candidate (@$slaves_list)
            {
                $result = wait_for_cctrl($master_candidate, $user_values, "ls $master_candidate", '', "$main_role:ONLINE", 5);
                print "# failing over to $master_candidate : ", ($result ? 'yes' : 'no'), "\n" if $CLI_Utils::VERBOSE;
                $timeout -= 5;
                if ( $result )
                {
                    $timeout = 0;
                    $slave = $master_candidate;
                    last;
                }
            }
        }

        #
        ####
        # my $failed_status= wait_for_cctrl($master, $user_values, "ls $master", '', 'REPLICATOR.* state=SUSPECT', 60);
        # ok(($failed_status || 0), 'Failed master replicator is not ONLINE within 60 seconds') 
        #     or return ;
        ####
        ok(($slave ne '<UNKNNOWN SLAVE>'), "$slave is '$main_role:ONLINE' after failover") and return $slave;
    }
    else
    {
        return 1;
    }
    return ;
}

######################################################
# test_table_contents
#
# Checks the contents of tables updated by Bristlecone
#
######################################################
sub test_table_contents
{
    my ($options) = @_;
    my $server_list = $options->{server_list};
    my $user_values = $options->{user_values};
    send_heartbeat($options);
    my $table_prefix = 'tbl';
    my $evaluator_db= 'evaluator';
    my %servers ;
    for my $group (qw(masters relays slaves))
    {
        for my $server (@{ $server_list->{$group}})
        {
            $servers{$server}{count} =undef;
            $servers{$server}{crc} =undef;
        }
    }
    my $MYSQL = sprintf("mysql -u %s -p%s -P %d",
        $user_values->{APPLICATION_USER},
        $user_values->{APPLICATION_PASSWORD},
        $user_values->{DATASOURCE_PORT});
    my $count_query = "select count(*) from $evaluator_db.${table_prefix}3"; 
    my $CRC_query = "checksum table $evaluator_db.${table_prefix}3"; 
    
    for my $server (sort keys %servers)
    {
        my $count = get_local_result(qq($MYSQL -h $server -BN -e '$count_query')) ;
        my $crc = get_local_result(qq($MYSQL -h $server -BN -e '$CRC_query')) ;
        if (defined($crc) && defined($count))
        {
            $crc =~ s/^.*\s+//;
            $servers{$server}{count} = $count;
            $servers{$server}{crc} = $crc;
        }
        else
        {
            ok(0, "server $server: can't get a count");
            return 1;
        }
    }
    my $compare_count = undef;
    my $compare_crc = undef;
    for my $server (sort keys %servers)
    {
        if (defined $compare_count)
        {
            ok($servers{$server}{count} == $compare_count, "$server: count ($servers{$server}{count}) is $compare_count") 
                or return 1;
        }
        else
        {
            $compare_count = $servers{$server}{count};
            return 1 unless defined $compare_count;
            ok($compare_count, "$server: initial count is $compare_count")
                or return 1;
        }
    }

    for my $server (sort keys %servers)
    {
        if (defined $compare_crc)
        {
            ok($servers{$server}{crc} eq $compare_crc, "$server: crc ($servers{$server}{crc}) is $compare_crc")
                or return 1;
        }
        else
        {
            $compare_crc = $servers{$server}{crc};
            ok($compare_crc, "$server: initial crc is $compare_crc")
                or return 1;
        }
    }
    return 0;
}


sub get_datasource
{
    my ($options, $server, $composite ) = @_;
    my $deployment_info = $options->{deployment_info};
    # print Dumper $deployment_info;
    if ( $composite && $deployment_info->{ 'composite_ds'})
    {
        return $deployment_info->{composite_ds};
    }
    for my $ds (keys %{ $deployment_info } )
    {
       next if $ds eq 'composite_ds';
       for my $group (qw(masters relays slaves))
        {
            if ($deployment_info->{$ds}{$group} && grep {$server eq $_} @{$deployment_info->{$ds}->{$group}} )
            {
                return $ds;
            }
        }
    } 
    die "could not find a datasource for server $server\n";
}


sub get_master
{
    my ($options) = @_;
    my $deployment_info = $options->{deployment_info};
    # print Dumper $deployment_info;
    my $master;
    for my $ds (keys %{ $deployment_info } )
    {
        next if $ds eq 'composite_ds';
        for my $server (@{ $deployment_info->{$ds}->{masters}}, 
                        @{$deployment_info->{$ds}->{relays}}, 
                        @{$deployment_info->{$ds}->{slaves}})
        {
            my $cctrl = get_cctrl($options->{user_values});
            my $result = get_remote_result($server,  "echo 'ls $server' | $cctrl" );
            if ($result =~ /$server\(master:ONLINE/)
            {
                return ($server, $ds);
            }
        }
    }     
    die "could not find an online master for this cluster\n";
}


sub get_slaves
{
    my ($options, $master) = @_;
    my $deployment_info = $options->{deployment_info};
    # print Dumper $deployment_info;
    for my $ds (keys %{ $deployment_info } )
    {
        next if $ds eq 'composite_ds';
        if ($deployment_info->{$ds}{masters} && (
             (grep {$master eq $_} @{$deployment_info->{$ds}->{masters}} )
             or
             (grep {$master eq $_} @{$deployment_info->{$ds}->{relays}} )))
        {
            my @servers ;
            for my $server (@{ $deployment_info->{$ds}->{masters}}, 
                            @{$deployment_info->{$ds}->{relays}}, 
                            @{$deployment_info->{$ds}->{slaves}})
            {
                # print "<<$server>>\n";
                next if $server eq $master;
                my $cctrl = get_cctrl($options->{user_values});
                my $result = get_remote_result($server,  "echo 'ls $server' | $cctrl" );
                # print "++$result\n";
                if ($result =~ /$server\(slave:/)
                {
                    push @servers, $server;
                } 
            }
            ok(1, "found @{[scalar @servers]} slaves in the DS containing $master");
            return @servers;
        }
    }
    ok( 0,  "could not find slaves in the DS containing $master\n");
    die "could not continue without slaves\n";
}

######################################################
# test failover
#
# Performs a failover and reports the result
#
######################################################
sub test_failover
{
    my ($options, $master, $slave, $user_values, $main_role, $policy_mode) = @_;
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }
    #print Dumper \@_;
    #print " fail_server($master, $slave, $user_values, $main_role);\n";
    my @slaves_list = get_slaves($options, $master);
    my $promoted_slave = fail_server($master, \@slaves_list, $user_values, $main_role, $policy_mode);
    wait_for_input();
    return 1 unless $promoted_slave;
    return test_server($promoted_slave,$main_role, $user_values, "$master failed over to $slave");
}

sub custom_die
{
    my ($msg) = @_;
    ok(0,$msg);
    die "Unrecoverable error\n";
}

######################################################################
# test after failover
#
# In a composite DS, tests if after failover the relay services are OK
#
######################################################################
sub test_after_failover
{
    my ($options,$deployment_info, $user_values) = @_;
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }

    my $cctrl = get_cctrl_with_options($user_values);
    my $master;
    my $master_ds;
    my @slave_ds;
    unless ($deployment_info->{composite_ds})
    {
        ok(0,   "found a composite dataservice in deployment_info");
        print Dumper $deployment_info;
        return 1;
    }
    for my $ds (keys %{ $deployment_info } )
    {
        next if $ds eq 'composite_ds';
        if ($deployment_info->{$ds}{masters} && $deployment_info->{$ds}{masters}[0] )
        {
            $master = $deployment_info->{$ds}{masters}[0];
            $master_ds = $ds;
        }
        elsif ($deployment_info->{$ds}{relays} && @{ $deployment_info->{$ds}{relays} })
        {
            push @slave_ds, $ds;
        }
        else
        {
            custom_die "Unrecognized composite dataservice. I could not find a master or a relay in $ds\n";
        }
    }
    unless ($master)
    {
        custom_die (  "test_after_failover - find a master in the deployment");
    }
    unless (@slave_ds)
    {
        custom_die( "test_after_failover - find composite slaves in the deployment");
    }

    my  $failover_to=$slave_ds[0];
    my $relay = $deployment_info->{$failover_to}{relays}[0] ;
    # Check for AUTOMATIC MODE
    my @new_slaves = @{$deployment_info->{$failover_to}{slaves}} ;
    ok($relay||0, "Relay server found after failover") or return;
    ok((@new_slaves) || 0, "Slaves from relay DS found after failover") or return;
    
    my $policy_automatic= wait_for_cctrl($relay, $user_values, "use $failover_to; ls $relay", '', 'COORDINATOR.*AUTOMATIC:\w+', 5);
    ok($policy_automatic || 0, "Policy is 'AUTOMATIC' after failover")
        or return 1;

    my $relay_is_master = wait_for_cctrl( $relay, $user_values, "use $failover_to; ls $relay", '-multi', "relay:ONLINE", 60);
    ok($relay_is_master || 0, "Server '$relay' is an ONLINE relay")
        or return 1;
    for my $slave (@new_slaves)
    {
        my $slave_online = wait_for_cctrl( $slave, $user_values, "use $failover_to; ls $slave", '-multi', "slave:ONLINE", 60);
        ok($slave_online || 0, "Slave $slave is ONLINE")
            or return 1;
        my $reports_to_relay = wait_for_cctrl( $slave, $user_values, "use $failover_to; ls $slave", '-multi', "role=slave, master=$relay", 60);
        ok($reports_to_relay || 0, "Slave $slave is a slave of $relay")
            or return 1;
    }
    return 0;
}


######################################################
# test recover
#
# Performs a recovery of a failed master and reports the result
#
######################################################
sub test_recover
{
    my ($master, $options, $user_values, $second_attempt) = @_;
    my $cctrl = get_cctrl_with_options($user_values);
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }

    my $recovery_status = get_remote_result($master, "echo datasource $master recover | $cctrl -expert"); 
    if ($recovery_status =~ /datasource $master restore/)
    {
        print "# recovery of '$master' failed - attempting backup and restore\n";
        return backup_and_restore($master, $options, $user_values);
    }
    elsif ($recovery_status =~ /server is not available/)
    {
        unless ($second_attempt)
        {
            print "# Server is not available. Attempting recovery again\n";
            return test_recover($master, $options, $user_values, 2);
        }
    }
    # print $recovery_status, "\n";
    ok(($recovery_status && ($recovery_status =~ /was successful/i)) || 0, "recovery of $master was successful ")
        or return 1;
    my $timeout =10;
    my $elapsed = 0;
    my $start_time = time();
    my $cctrl_status;
    while ($elapsed < $timeout)
    {
        $cctrl_status = get_remote_result($master, "echo ls $master | $cctrl -expert");
        if ($cctrl_status && ($cctrl_status =~ /$master\(\S+:ONLINE/i))
        {
            last;
        }
        $elapsed = time() - $start_time; 
    }
    ok(($cctrl_status && ($cctrl_status =~ /$master\(\S+:ONLINE/i)) || 0, "$master online within $timeout seconds after restore")
        or return 1;
    return 0; 
}

sub get_backup_directory
{
    my ($server,$user_values, $options) = @_;
    my $ds = get_datasource($options,$server);
    my $continuent_root = $user_values->{CONTINUENT_ROOT}
        or custom_die "(get_backup_directory) - can't figure out where \$CONTINUENT_ROOT is\n";
    my $old_replicator_conf = "$continuent_root/tungsten/tungsten-replicator/conf/replicator.properties";
    my $new_replicator_conf = "$continuent_root/tungsten/tungsten-replicator/conf/static-$ds.properties";
    my $replicator_conf = $old_replicator_conf;
    if ($tungsten_version > 1)
    {
        $replicator_conf= $new_replicator_conf;
    }
    my $property_name ='replicator.storage.agent.fs.directory' ;
    my $backup_dir_property = get_remote_result($server, "grep '$property_name' $replicator_conf" );
    my $backup_dir;
    if ($backup_dir_property =~ /^$property_name=(.+)/)
    {
        $backup_dir = $1; 
    }
    else
    {
        custom_die "cannot determine the backup directory for server $server\n";
    }
    #my $dir_exists = get_remote_result($server, "if [ -d $backup_dir ] ; then echo OK ; else echo no; fi");
    unless (remote_file_test($server, $backup_dir, '-d'))
    {
        custom_die "cannot determine the backup directory for server $server\n";
    }
    # print ">>$server $backup_dir\n";
    return $backup_dir;
}

sub backup_and_restore
{
    my ($failed_server, $options, $user_values, $preferred_slaves) = @_;

    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }
    my $server_list = $options->{server_list};
    my $cctrl = get_cctrl_with_options($user_values);
    my $backup_slave ;
    unless ($backup_taken)
    {
        my $timeout= 30;
        my $elapsed = 0;
        my $slave_status;
        SLAVE_SEARCH:
        while ($elapsed < $timeout)
        {
            my @preferential_list= ();
            if ($preferred_slaves && (ref($preferred_slaves) eq 'ARRAY'))
            {
                @preferential_list = @$preferred_slaves;
            }
            for my $slave (@preferential_list, @{$server_list->{slaves}}, @{$server_list->{relays}} )
            {
                next unless $slave;
                next if $failed_server and ($failed_server eq $slave);
                $slave_status = get_remote_result($slave, "echo ls $slave | $cctrl -expert"); 
                my $current_server_status ='';
                if ($slave_status =~ /($slave\([^)]+\))/)
                {
                    $current_server_status = $1;
                }
                print_log( "# (Searching for a backup slave - elapsed: $elapsed) $current_server_status\n",1);
                if ($CLI_Utils::VERBOSE)
                {
                    print "# (Searching for a backup slave - elapsed: $elapsed) $current_server_status\n" if $CLI_Utils::VERBOSE;
                }
                if ($slave_status =~ /(?:slave|relay):ONLINE/)
                {
                    $backup_slave = $slave;
                    last SLAVE_SEARCH;
                }
            }
            $elapsed++;
            sleep 1;
        }
    
        ok(defined($backup_slave), 'Found a slave to take a backup')
            or return 1;
        my $backup_directory = get_backup_directory($backup_slave, $user_values, $options);
        # my $files_before_backup = get_dir_files($backup_slave, $backup_directory);
        my $backup_status = get_remote_result($backup_slave, "echo datasource $backup_slave backup | $cctrl -expert"); 
        ok(($backup_status && ($backup_status =~ /Backup of dataSource '$backup_slave' succeeded/i )) || 0, "Backup from $backup_slave was successful" )
            or return 1;
        my $files_after_backup = get_dir_files($backup_slave, $backup_directory);
        if ($options->{copy_backups})
        {
            copy_to_all_datasources($backup_slave, $backup_directory, $files_after_backup, $server_list);
        }
        else
        {
            wait_for_backup_files($backup_slave, $backup_directory, $files_after_backup, $server_list);
        }
    }

    $backup_taken =1;
    return 0 unless $failed_server;

    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }
    # print ">> starting restore\n";
    my $restore_status = get_remote_result($failed_server, "echo datasource $failed_server restore | $cctrl -expert"); 
    ok(($restore_status && ($restore_status =~ /DATASOURCE '$failed_server' WAS RESTORED SUCCESSFULLY/i)) || 0, "restore of $failed_server was successful ")
        or return 1;
    return 0;
}

sub wait_for_backup_files
{
    my ($from_server, $directory, $files, $server_list) = @_;
    my %servers ;
    for my $group (qw(masters relays slaves))
    {
        for my $server (@{ $server_list->{$group}})
        {
            next if $server eq $from_server;
            $servers{$server} =1;
        }
    }
    my $files_to_check = scalar(keys %servers) * scalar(@$files);
    my $timeout = 120;
    my $elapsed = 0;
    my %seen;
    my $total_seen =0;
    while ($elapsed < $timeout)
    {
        for my $to_server (sort keys %servers)
        {
            for my $file (@{$files})
            {
                next if $seen{$file}{$to_server};
                #my $file_exists = get_remote_result($to_server, "if [ -f $directory/$file ] ; then echo OK ; else echo no; fi");
                #if ($file_exists && ($file_exists eq 'OK'))
                if (remote_file_test($to_server, "$directory/$file", '-e'))
                {
                    # print ">> looking for file $directory/$file in $to_server\n";
                    $seen{$file}{$to_server}++;
                    $total_seen++;
                }
            }
        }
        # print "++ total: $total_seen ($files_to_check)\n";
        last if $total_seen >= $files_to_check;
        sleep 1;
        $elapsed++;
    }
    # print "+++ total: $total_seen ($files_to_check)\n";
    if ($total_seen < $files_to_check)
    {
        my @server_list= keys %servers;
       custom_die( "Backup files were copied from $from_server to (@server_list) within $timeout seconds");
    }
}

sub copy_to_all_datasources
{
    my ($from_server, $directory, $files, $server_list) = @_;
    my %servers ;
    for my $group (qw(masters relays slaves))
    {
        for my $server (@{ $server_list->{$group}})
        {
            next if $server eq $from_server;
            $servers{$server} =1;
        }
    }
    for my $to_server (sort keys %servers)
    {
        for my $file (@{$files})
        {
            my $will_copy = 1;
            #my $file_exists = get_remote_result($to_server, "if [ -f $directory/$file ] ; then echo OK ; else echo no; fi");
            #if ($file_exists && ($file_exists eq 'OK'))
            if (remote_file_test($to_server, "$directory/$file", '-f'))
            {
                my $dest_file   = get_remote_result($to_server,   "md5sum $directory/$file");
                my $source_file = get_remote_result($from_server, "md5sum $directory/$file");
                if ($dest_file && $source_file && ($dest_file eq $source_file))
                {
                    $will_copy =0;
                }
            }
            if ($will_copy)
            {
                #get_remote_result($from_server, "$SCP -q $directory/$file $to_server:$directory/" );
                get_remote_result($from_server, "$SCP -o StrictHostKeyChecking=no $directory/$file $SSH_USER\@$to_server:$directory/" );
            }
        }
    }
}

sub get_dir_files
{
    my ($server, $directory) = @_;
    my $files_text = get_remote_result($server , "ls $directory");
    my @files = split ' ', $files_text;
    return \@files;
}

######################################################
# test switch
#
# Performs a switch and reports the result
#
######################################################
sub test_switch
{
    my ($options,$master, $slave, $user_values) = @_;
    my $cctrl = get_cctrl_with_options($user_values);
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }

    my $cctrl_switch_status = get_remote_result($master, "echo switch to $slave | $cctrl"); 
    ok(($cctrl_switch_status && ($cctrl_switch_status =~ /was successful/i)) || 0, "SWITCH to $slave was successful ")
        or return 1;
    return 0;
}

######################################################
# test composite failover
#
# Performs a failover on a composite dataservice
#
######################################################
sub test_composite_failover
{
    my ($options,$deployment_info, $user_values, $failover_to) = @_;
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }

    my $cctrl = get_cctrl_with_options($user_values);
    my $master ;
    my $master_ds;
    my @slave_ds;
    unless ($deployment_info->{composite_ds})
    {
        ok(0,   "found a composite dataservice in deployment_info");
        print Dumper $deployment_info;
        return ;
    }
    for my $ds (keys %{ $deployment_info } )
    {
        next if $ds eq 'composite_ds';
        if ($deployment_info->{$ds}{masters} && $deployment_info->{$ds}{masters}[0] )
        {
            $master = $deployment_info->{$ds}{masters}[0];
            $master_ds = $ds;
        }
        elsif ($deployment_info->{$ds}{relays} && @{ $deployment_info->{$ds}{relays} })
        {
            push @slave_ds, $ds;
        }
        else
        {
            custom_die "Unrecognized composite dataservice. I could not find a master or a relay in $ds\n";
        }
    }
    unless ($master)
    {
        custom_die(  "test_composite_failover - find a master in the deployment");
    }
    unless (@slave_ds)
    {
        custom_die( "test_composite_failover - find composite slaves in the deployment");
    }

    unless ($failover_to)
    {
        $failover_to=$slave_ds[0];
    }
    my $relay = $deployment_info->{$failover_to}{relays}[0] ;
    my @servers_list = ($master, @{ $deployment_info->{$master_ds}{slaves}});
    my $num_servers = scalar @servers_list;
    my @preferred_slaves_for_backup = get_slaves($options, $servers_list[0]);
    if (@preferred_slaves_for_backup)
    {
        print "# Taking a precautionary backup before failover\n" if $CLI_Utils::VERBOSE;
        # We want to use a backup from a slave close to the master we're going to fail
        # For this reason, we discard backups that may have been taken before.
        #unless ($options->{backup_first})
        #{
            $backup_taken=0;
        #}
        my $result = backup_and_restore(undef, $options, $user_values, \@preferred_slaves_for_backup);
        ok ( (!$result), 'precautionary backup succeeded' );
        return 1 if $result;
    }
    for my $N (0 .. $num_servers -2)
    {
        my @slaves_list = get_slaves($options, $servers_list[$N]);
        my $new_master;
        unless ($new_master = fail_server($servers_list[$N], \@slaves_list, $user_values,'master'))
        {
            ok(0, "failing server $servers_list[$N]\n");
            return ;
        }
        my $policy_automatic =wait_for_cctrl($relay, $user_values, "use $failover_to; ls $relay", '', 'COORDINATOR.*AUTOMATIC:\w+', 60);
        ok($policy_automatic || 0, "Policy is 'AUTOMATIC' after server failover") 
            or return;
        my $relay_online = wait_for_cctrl($relay, $user_values, "use $failover_to; ls $relay", '', "relay:ONLINE", 5);
        ok($relay_online || 0 , "relay '$relay' is ONLINE")
            or return;
        my $report_to_new_master= wait_for_cctrl($relay, $user_values, "use $failover_to; ls $relay", '', "role=relay, master=$new_master", 5);
        ok($report_to_new_master || 0, "relay '$relay' reports to master '$new_master'")
            or return;
    } 
    # my @slaves_list = get_slaves($options, $servers_list[-1]);
    unless (fail_server($servers_list[-1], undef, $user_values,''))
    {
        ok(0, "failing server $servers_list[-1]");
        return ;
    }
    wait_for_input();
    # gets the latest master in the site
    $master = $servers_list[-1];

    unless (wait_for_cctrl($master, $user_values, "use $deployment_info->{composite_ds}; ls", '-multi', "$master_ds.composite master:FAILED", 10))
    {
        ok(0, "composite master $master_ds marked as FAILED"); 
        return ; 
    }
    wait_for_input();
    # print qq[{@slave_ds} $master, "echo 'use $deployment_info->{composite_ds}; failover to $failover_to' | $cctrl -multi -expert"\n]; 
    my $cctrl_status = get_remote_result($master, "echo 'use $deployment_info->{composite_ds}; failover to $failover_to' | $cctrl -multi -expert"); 
    ok(($cctrl_status && ($cctrl_status =~ /was successful/i)) || 0, "composite failover to $failover_to was successful" )
        or return ;
    # Check for AUTOMATIC MODE
    my @new_slaves = @{$deployment_info->{$failover_to}{slaves}} ;
    ok($relay||0, "Former relay server found after failover") or return;
    ok((@new_slaves) || 0, "Slaves from former relay DS found after failover") or return;
    
    my $policy_automatic= wait_for_cctrl($relay, $user_values, "use $failover_to; ls $relay", '', 'COORDINATOR.*AUTOMATIC:\w+', 5);
    ok($policy_automatic || 0, "Policy is 'AUTOMATIC' after composite failover")
        or return;

    my $relay_is_master = wait_for_cctrl( $relay, $user_values, "use $failover_to; ls $relay", '-multi', "master:ONLINE", 60);
    ok($relay_is_master || 0, "Former relay '$relay' is now an ONLINE master")
        or return;
    for my $slave (@new_slaves)
    {
        my $slave_online = wait_for_cctrl( $slave, $user_values, "use $failover_to; ls $slave", '-multi', "slave:ONLINE", 60);
        ok($slave_online || 0, "Slave $slave is ONLINE")
            or return;
        my $reports_to_relay = wait_for_cctrl( $slave, $user_values, "use $failover_to; ls $slave", '-multi', "role=slave, master=$relay", 60);
        ok($reports_to_relay || 0, "Slave $slave is a slave of $relay")
            or return;
    }
    return ($master_ds, $master);
}


######################################################
# test composite recovery
#
# Performs a failover on a composite dataservice
#
######################################################
sub test_composite_recovery
{
    my ($deployment_info, $user_values, $failed_ds, $old_master, $options) = @_;
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }

    my $cctrl = get_cctrl_with_options($user_values);

    my $cctrl_status = get_remote_result($old_master, "echo 'use $deployment_info->{composite_ds}; recover using $old_master' | $cctrl -multi -expert"); 
    my $recovery_complete = 0;
    if ($cctrl_status && ($cctrl_status =~ /RECOVERY OF COMPOSITE SERVICE '$deployment_info->{composite_ds}' IS COMPLETE/i))
    {
        $recovery_complete = 1;
    }
   
    if ($cctrl_status && ($cctrl_status =~ /datasource (\S+) restore/))
    {
        my $restore_candidate = $1;
        print "# recovery of $failed_ds using '$old_master' failed - attempting backup and restore\n";
        if ( backup_and_restore($restore_candidate, $options, $user_values))
        {
            return 1;
        }
    }
    else
    {
        ok( $recovery_complete, "composite recovery of $failed_ds was successful" )
        or return 1;
    }
    # 
    # Before continuing, we check if the server was recovered correctly:
    #
    my $server_status = test_server($old_master, 'relay', $user_values);
    ok(($server_status == 0 ), "# RECOVERY was reported as complete, and the relay is fully online")
        or return 1;
 
    my $timeout = 10;
    my $elapsed = 0;
    my $start_time=time;
    while ($elapsed < $timeout)
    {
        $cctrl_status = get_remote_result($old_master, "echo 'use $deployment_info->{composite_ds}; ls $failed_ds' | $cctrl -multi -expert"); 
        if ($cctrl_status && ($cctrl_status =~/$failed_ds\(composite slave:ONLINE/i))
        {
            last;
        }
        if ($cctrl_status && ($cctrl_status =~/$failed_ds\(composite slave:OFFLINE/i))
        {
            print "# Found an OFFLINE site. Attempting to put it online manually\n";
            get_remote_result($old_master, "echo 'use $deployment_info->{composite_ds}; cluster online' | $cctrl -multi -expert");
        }
        $elapsed = time() - $start_time;
    }
    ok(($cctrl_status && ($cctrl_status =~ /$failed_ds\(composite slave:ONLINE/i)) || 0, "$failed_ds is now a composite online slave (within $timeout seconds)" )
        or return 1;

    $cctrl_status = get_remote_result($old_master, "echo 'ls $old_master' | $cctrl -expert"); 
    ok(($cctrl_status && ($cctrl_status =~ /relay:ONLINE/i)) || 0, "$old_master is now online (relay)" )
        or return 1;
    # checks if any further recovery is needed
    for my $server (  @{ $deployment_info->{$failed_ds}{slaves} }, @{ $deployment_info->{$failed_ds}{masters} }, @{$deployment_info->{$failed_ds}{relays}} )
    {
        $cctrl_status = get_remote_result($server, "echo 'ls $server' | $cctrl -expert"); 
        wait_for_input();
        unless ($cctrl_status =~ /(?:slave|master|relay):ONLINE/i)
        {
            sleep 1;
            $cctrl_status = get_remote_result($server, "echo 'datasource $server recover' | $cctrl -expert"); 
            if ($cctrl_status =~ /datasource $server restore/)
            {
                print "# recovery of '$server' failed - attempting backup and restore\n";
                if ( backup_and_restore($server, $options, $user_values))
                {
                    return 1;
                }
            }
            else
            {
                if ($cctrl_status =~ /server is not available/)
                {
                    $cctrl_status = get_remote_result($server, "echo datasource $server recover | $cctrl -expert"); 
                }
                ok(($cctrl_status && ($cctrl_status =~ /was successful/i)) || 0, "manual recovery of $server succeeded" )
                    or return 1;
            }
            $cctrl_status = get_remote_result($server, "echo 'ls $server' | $cctrl -expert"); 
            ok(($cctrl_status && ($cctrl_status =~ /(?:slave|relay|master):ONLINE/i)) || 0, "$server is now online" )
                or return 1;
        }
    }
    my $original_master = $deployment_info->{$failed_ds}{masters}[0];

    $cctrl_status = get_remote_result($original_master, "echo 'ls $original_master' | $cctrl -expert"); 
    if ($cctrl_status =~ /slave:ONLINE/)
    {
        return test_switch($options,$old_master, $original_master, $user_values);
    }
    return 0;
}


######################################################
# test composite switch
#
# Performs a switch on a composite dataservice
#
######################################################
sub test_composite_switch
{
    my ($options,$deployment_info, $user_values, $switch_to) = @_;
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }
    my $cctrl = get_cctrl_with_options($user_values);
    my $master ;
    my $master_ds;
    my @slave_ds;
    unless ($deployment_info->{composite_ds})
    {
        return 0;
    }
    for my $ds (keys %{ $deployment_info } )
    {
        next if $ds eq 'composite_ds';
        if ($deployment_info->{$ds}{masters} && $deployment_info->{$ds}{masters}[0] )
        {
            $master = $deployment_info->{$ds}{masters}[0];
            $master_ds = $ds;
        }
        elsif ($deployment_info->{$ds}{relays} && @{ $deployment_info->{$ds}{relays} })
        {
            push @slave_ds, $ds;
        }
        else
        {
            custom_die "Unrecognized composite dataservice. I could not find a master or a relay in $ds\n";
        }
    }
    unless ($master)
    {
        custom_die( "test_composite_switch - can't find a master in the deployment");
    }
    unless (@slave_ds)
    {
        custom_die("test_composite_switch - can't find composite slaves in the deployment");
    }

    unless ($switch_to)
    {
        $switch_to=$slave_ds[0];
    }
    # print qq[{@slave_ds} $master, "echo 'use $deployment_info->{composite_ds}; switch to $switch_to' | $cctrl -multi -expert"\n]; 
    my $cctrl_status = get_remote_result($master, "echo 'use $deployment_info->{composite_ds}; switch to $switch_to' | $cctrl -multi -expert"); 
    ok(($cctrl_status && ($cctrl_status =~ /was successful/i)) || 0, "composite switch to $switch_to was successful" )
        or return 1;
    if ( test_composite_dataservice($options, $deployment_info,$user_values, $switch_to))
    {
        return 1;
    }
    if ($switch_to eq $master_ds)
    {
        return 0;
    }
    $cctrl_status = get_remote_result($master, "echo 'use $deployment_info->{composite_ds}; switch to $master_ds' | $cctrl -multi -expert"); 
    ok(($cctrl_status && ($cctrl_status =~ /was successful/i)) || 0, "composite switch to $master_ds was successful" )
        or return 1;
    return test_composite_dataservice($options, $deployment_info,$user_values, $master_ds);
}



######################################################
# test composite dataservice
#
# Performs a simple test on a composite dataservice
#
######################################################
sub test_composite_dataservice
{
    my ($options,$deployment_info, $user_values, $intended_master) = @_;
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }

    my $cctrl = get_cctrl_with_options($user_values);
    my $master;
    my $master_ds;
    my @slave_ds;
    unless ($deployment_info->{composite_ds})
    {
        return 0;
    }
    for my $ds (keys %{ $deployment_info } )
    {
        next if $ds eq 'composite_ds';
        if ($deployment_info->{$ds}{masters}[0])
        {
            $master = $deployment_info->{$ds}{masters}[0];
            if ($intended_master && ($intended_master ne $ds))
            {
                push @slave_ds, $ds;
            }
            else
            {
                $master_ds = $ds;
            }
        }
        elsif ($deployment_info->{$ds}{relays})
        {
            if ($intended_master && ($intended_master eq $ds))
            {
                $master_ds = $intended_master;
            }
            else
            {
                push @slave_ds, $ds;
            }
        }
        else
        {
            custom_die "Unrecognized composite dataservice. I could not find a master or a relay in $ds\n";
        }
    }
    unless ($master)
    {
        custom_die( "test_composite_dataservice - find a master in the deployment \n");
    }

    #
    # Checks that a given role is ONLINE on the server
    #
    #my $cctrl_status = get_remote_result($master, "echo 'use $deployment_info->{composite_ds}; ls' | $cctrl -multi | grep :ONLINE"); 
    my $cctrl_status = get_remote_result($master, "echo 'use $deployment_info->{composite_ds}; ls' | $cctrl -multi"); 
    if ($cctrl_status =~ /(?:master|slave):OFFLINE/)
    {
        print "# Found an OFFLINE site. Attempting to put it online manually\n";
        get_remote_result($master, "echo 'use $deployment_info->{composite_ds}; cluster online' | $cctrl -multi"); 
        $cctrl_status = get_remote_result($master, "echo 'use $deployment_info->{composite_ds}; ls' | $cctrl -multi"); 
    }
    ok(($cctrl_status && ($cctrl_status =~ /$master_ds\(composite master:ONLINE\)/)) || 0, "$master_ds is the composite master" )
        or return 1;
    for my $slave (@slave_ds)
    {
        ok(($cctrl_status && ($cctrl_status =~ /$slave\(composite slave:ONLINE\)/)) || 0, "$slave is a composite slave" )
            or return 1;
    }
    return 0;
}


######################################################
# test server
#
# Performs a simple test on each server
#
######################################################
sub test_server
{
    my ($server, $role, $user_values, $custom_message) = @_;
    my $cctrl = get_cctrl($user_values);
    my $cctrl_with_options = get_cctrl_with_options($user_values);
    my $manager = "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-manager/bin/manager";
    # print "++$server, $role, ", $custom_message ||'', "\n";
    unless ($custom_message)
    {
        #
        # Checks that a manager exists on the server and it is running
        #
        #my $manager_exists = get_remote_result($server, "if [ -x $manager ] ; then echo OK ; else echo no; fi");
        my $manager_exists = remote_file_test($server, $manager, '-x');
        ok(($manager_exists) || 0, "manager exists on server $server") 
            or return 1;
        my $manager_status = get_remote_result($server, "$manager status"); 
        ok(($manager_status && ($manager_status =~ /is running/)) || 0, qq(manager status: "$manager_status"))
            or return 1;
        #
        # Checks that a cctrl exists on the server
        #
        #my $cctrl_exists = get_remote_result($server, "if [ -x $cctrl ] ; then echo OK ; else echo no; fi");
        my $cctrl_exists = remote_file_test($server, $cctrl, '-x');
        ok(($cctrl_exists) || 0, "cctrl exists on server $server")
            or return 1;
        $custom_message = "$server: there is an ONLINE $role ";
    }

    my $test_server_timeout = 40;
    my $start_time = time();
    my $end_time = $start_time + $test_server_timeout;
    #
    # Checks that a given role is ONLINE on the server
    #
    # my $cctrl_status = get_remote_result($server, "echo ls $server | $cctrl_with_options | grep $role:ONLINE"); 
    my $cctrl_status='';
    my $return_code = 0;
    my $items_checked =0;
    my %status_components = (
        datasource  => { display=>1, checked => 0, message => 'ONLINE', wanted => "$role:ONLINE"},
        status      => { display=>2, checked => 0, message => 'OK',     wanted => 'STATUS \[OK\]'},
        manager     => { display=>3, checked => 0, message => 'ONLINE', wanted => 'MANAGER\(state=ONLINE\)'},
        replicator  => { display=>4, checked => 0, message => 'ONLINE', wanted => 'REPLICATOR.*state=ONLINE'},
        database    => { display=>5, checked => 0, message => 'ONLINE', wanted => 'DATASERVER\(state=ONLINE\)'},
    );
    my $items_to_check = scalar keys %status_components;
    while (1)
    {
        last if ($items_checked >= $items_to_check);
        if (time() >= $end_time)
        {
            print "# $server : timeout exceeded: aborting \n" if $CLI_Utils::VERBOSE;
            last;
        }
        for my $component (keys %status_components)
        {
            $cctrl_status = get_remote_result($server, "echo ls $server | $cctrl_with_options"); 
            next if $status_components{$component}{checked};
            my $wanted = $status_components{$component}{wanted};
            # print "# checking $server $component - wanted: /$wanted/ (items checked: $items_checked)\n" if $CLI_Utils::VERBOSE;
            if ($cctrl_status && ($cctrl_status =~ /$wanted/) )
            {
                $status_components{$component}{checked} =1;
                $items_checked ++;
            }
        }
    }
    # After timeout and full checking, we sort out the results
    my $save_skip_status= $skip_status_in_log;
    $skip_status_in_log=1;
    for my $component (sort { $status_components{$a}{display} <=> $status_components{$b}{display}}  keys %status_components)
    {
        ok($status_components{$component}{checked}, "$server: $component $status_components{$component}{message}")
            or $return_code++; 
    }
    $skip_status_in_log = $save_skip_status; 
    return $return_code;
}

sub get_query_result_with_timeout
{
    my $use_time_hires =1;
    eval "use Tume::HiRes qw(usleep gettimeofday tv_interval)";
    if ($@)
    {
        $use_time_hires = 0;
    }
    my ($cmd, $wanted, $timeout, $interval) = @_;
    my $elapsed =0;
    my $operation = '==';
    if ($wanted =~ s/^(=|>=|>|<=|<)//)
    {
        $operation = $1;
    }
    #elsif ($wanted =~ s/^>//)
    #{
    #    $operation = '>';
    #}
    #elsif ($wanted =~ s/^<=//)
    #{
    #    $operation = '<=';
    #}
    #elsif ($wanted =~ s/^<//)
    #{
    #    $operation = '<';
    #}
    unless ($interval)
    {
        $interval = $use_time_hires ? 100_000 : 1;
    }
    unless ($timeout)
    {
        $timeout = 1;
    }
    my $start_time;
    if ($use_time_hires)
    {
        $start_time = [gettimeofday()];
    }
    while ($elapsed < $timeout)
    {
        my $result = get_local_result($cmd);
        # print "$cmd <$result> <$wanted>\n";
        if (defined($result) )
        {
            my $evaluation;
            print_log (qq(eval "\$evaluation = $result $operation $wanted"\n), 1);
            eval "\$evaluation = $result $operation $wanted";
            print_log (qq(eval "\$evaluation = ) . ($evaluation || ' --- ' ) . qq(\n, 1));
            if ($evaluation) 
            {
                return $result;
            }
        }
        if ($use_time_hires)
        {
            usleep($interval);
            $elapsed = tv_interval( $start_time, [gettimeofday()]);
        }
        else
        {
            sleep($interval);
            $elapsed++; 
        }
        # my $time = scalar localtime; print "### ($time) $elapsed\n";
    } 
    return ;
}

sub send_heartbeat
{
    my ($options) = @_;
    my ( $master, $ds) = get_master($options);
    my $user_values = $options->{user_values};
    unless ($user_values )
    {
        die "Before calling 'send_heartbeat', metadata should be collected using 'fill_template'\n";
    }
    my $cctrl = get_cctrl($user_values);
    my $result  = get_remote_result($master, "echo 'use $ds; cluster heartbeat' | $cctrl -multi");
}


###################################################################
# test replication
#
# Tests that data created on the master will end up in all slaves
# and that Tungsten is recording the transaction metadata
###################################################################
sub test_replication
{
    my ($options, $server_list, $user_values) = @_;
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }

    my $MYSQL_CONNECTOR = sprintf("mysql -u %s -p%s -P %d",
        $user_values->{APPLICATION_USER},
        $user_values->{APPLICATION_PASSWORD},
        $user_values->{APPLICATION_PORT});
    my $MYSQL_REGULAR = sprintf("mysql -u %s -p%s -P %d",
        $user_values->{APPLICATION_USER},
        $user_values->{APPLICATION_PASSWORD},
        $user_values->{DATASOURCE_PORT});
     my $MASTER_NUM=0;
    my %server_ids;
    my $result;
    my$master_seqno=0;
    my $replication_timeout=10;
 
    my $server = $server_list->{connectors}[0];
    unless ($server)
    {
        ok(0, "can't run replication test without connectors");
        return 1;
    }
    #for my $server (@{$server_list->{masters}})
    #{
    my ($master, $master_ds) = get_master($options);
       my $server_id = get_local_result(qq($MYSQL_CONNECTOR -h $server -BN -e "select \@\@server_id"));
        ok(($server_id && ($server_id =~ /^\d+$/)) || 0, "got SERVER ID for $server - $server_id")
            or return 1;
        $server_ids{$server} = $server_id;
        $result = get_local_result(qq($MYSQL_CONNECTOR -h $server -e "/* 1 */ create schema if not exists test"));
        ok(!$result, "master $server can create a schema")
            or return 1;
        #$result = get_local_result(qq($MYSQL_CONNECTOR -h $server -e "tungsten connection status"));
        $result = get_local_result(qq($MYSQL_CONNECTOR -h $server -e "/* 2 */ use test;drop table if exists TC_t$MASTER_NUM"));
        ok(!$result, "master $server can drop a table")
            or return 1;
        #$result = get_local_result(qq($MYSQL_CONNECTOR -h $server -e "tungsten connection status"));
        $result = get_local_result(qq[$MYSQL_CONNECTOR -h $server -e "/* 3 */ use test;create table TC_t$MASTER_NUM(i int not null primary key, v varchar(100)) engine=innodb"]);
        ok(!$result, "master $server can create a table")
            or return 1;
        $result = get_local_result(qq[$MYSQL_CONNECTOR -h $server -e "/* 4 */ use test;insert into TC_t$MASTER_NUM values ($server_id, '$server')"]);
        ok(!$result, "master $server can insert a record")
            or return 1;
        #$result = get_local_result(qq($MYSQL_CONNECTOR -h $server -e "tungsten connection status"));
        my $ds = get_datasource($options, $server, 'composite');
        # print "v: $tungsten_version - ds: $ds\n";
        if ($tungsten_version > 1)
        {
            $TUNGSTEN_SCHEMA = 'tungsten_' . $ds; 
        }
        else
        {
            $TUNGSTEN_SCHEMA = 'tungsten';
        }
        $master_seqno = get_local_result(qq[$MYSQL_CONNECTOR -h $server -BN -e "/* 5 */ select max(seqno) from $TUNGSTEN_SCHEMA.trep_commit_seqno"]);
        ok($master_seqno, "master seqno ($master_seqno) is > 0")
            or return 1;
        #$result = get_local_result(qq($MYSQL_CONNECTOR -h $server -e "tungsten connection status"));
        $MASTER_NUM++;
    #}
    sleep 1;
    for my $server ( @{$server_list->{slaves}}, @{$server_list->{relays}})
    {
        send_heartbeat($options);
        my $query = qq[select count(*) from tables where table_schema='test' and table_name like 'TC_t%'];
        $result = get_query_result_with_timeout(qq[$MYSQL_REGULAR -f -b -BN -h $server -e "/* 6 */ use information_schema; $query"], $MASTER_NUM, $replication_timeout);
        ok((defined $result && ($result eq $MASTER_NUM)) || 0, "slave $server got tables from master ")
            or return 1;

        my $mnum =0;
        while ($mnum < $MASTER_NUM)
        {
            $result = get_query_result_with_timeout(qq[$MYSQL_REGULAR -b -f -BN -h $server -e "/* 7 */use test; select count(*) from TC_t$mnum"],'1', $replication_timeout);
            ok(($result && ($result eq '1')) || 0, "slave $server can retrieve records from the master")
                or return 1;
            my $slave_ds = get_datasource($options, $server, 'composite') ;
            if ($tungsten_version > 1)
            {
                $TUNGSTEN_SCHEMA = 'tungsten_' . $slave_ds; 
            }
            else
            {
                $TUNGSTEN_SCHEMA = 'tungsten';
            } 
            my $slave_seqno = get_query_result_with_timeout(qq[$MYSQL_REGULAR -h $server -BN -e "/* 8 */ select max(seqno) from $TUNGSTEN_SCHEMA.trep_commit_seqno"], ">=$master_seqno",$replication_timeout);
            $slave_seqno = 0 unless defined $slave_seqno;
            $slave_seqno =~ s/^s\*//;
            $slave_seqno =~ s/s\*$//;
            ok($slave_seqno >= $master_seqno, "server $server seqno ($slave_seqno) is greater or equal to $master_seqno")
                or return 1;
            $mnum++;
        }
    }

    $MASTER_NUM=0;
    $server = $server_list->{connectors}[0];
    #for my $server (@{$server_list->{masters}})
    #{
        $server_id = $server_ids{$server};
        $result = get_local_result(qq($MYSQL_CONNECTOR -f -b -h $server -e "/* 9 */ use test;drop table TC_t$MASTER_NUM"));
        ok(!$result, "master $server can drop a table")
            or return 1;
        $MASTER_NUM++;
    #}
    sleep 1;
    for my $server ( @{$server_list->{slaves}}, @{$server_list->{relays}})
    {
        my $mnum =0;
        while ($mnum < $MASTER_NUM)
        {
            my $query = qq[select count(*) from tables where table_schema='test' and table_name='TC_t$mnum'];
            my $result = get_query_result_with_timeout(qq[$MYSQL_REGULAR -BN -h $server -e "/* 10 */ use information_schema; $query"], '0', $replication_timeout);
            ok((defined $result && ($result eq '0')) || 0, "slave $server can drop a table ")
                or return 1;
            $mnum++;
        }
    }
    return 0;
}


######################################################
# test direct connector
#
# Tests that a direct connector returns a connection
# to a given role
######################################################
sub test_direct_connector
{
    my ($options,$server, $requested, $user_values) = @_;
    my $expected = $requested;
    if ($expected eq 'slave')
    {
        $expected = '(?:slave|relay)';
    }
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }

    my $query = qq{tungsten connection status };
    my $MYSQL = "mysql -u $user_values->{APPLICATION_USER} -p$user_values->{APPLICATION_PASSWORD}";
    my $result = get_local_result(qq($MYSQL -P $user_values->{APPLICATION_PORT} -h $server -B -N -e "$query"));
    my $is_expected = 
    ok(($result && ($result =~ /$expected/)) || 0, "server $server - direct connection to $requested")
        or return 1;
    return 0;
}

######################################################
# test connector
#
# Checks that a connector returns the expected
# result for smartscale.
# It does implicitly check that the connector 
# is working
######################################################
sub test_connector
{
    my ($options,$server, $expected, $user_values) = @_;
    if ($options->{log_cluster_status})
    {
        get_cluster_status($options, "log_status");
    }

    my $query = qq{tungsten show variables like 'useSmartScale'};
    my $MYSQL = "mysql -u $user_values->{APPLICATION_USER} -p$user_values->{APPLICATION_PASSWORD}";
    my $result = get_local_result(qq($MYSQL -P $user_values->{APPLICATION_PORT} -h $server -B -N -e "$query"));
    if ($result) 
    {
        $result = (split ' ', $result) [-1];
    }
    else 
    {
        $result = '';
    }
    ok($result eq $expected, "server $server - smartscale as expected: $expected")
        or return 1;
    return 0;
}

######################################################
# uninstall cluster
#
# Using the metadata gathered from a recipe,
# uninstalls Tungsten and clears the database servers
#
######################################################
sub uninstall_cluster
{
    my ($options, $just_prepare) = @_;
    my $user_values = $options->{user_values};
    my $cluster_info = $options->{cluster_info};
    my $server_list  = $options->{server_list};
    unless ($user_values && $cluster_info && $server_list)
    {
        die "Before calling 'uninstall_cluster', metadata should be collected using 'fill_template'\n";
    }
    my %servers ;
    #
    # Since a server can be listed for several functions (e.g. slave and connector),
    # First we build a unique list
    #
    for my $list (keys %{ $server_list })
    {
        next unless ref($server_list->{$list}) && (ref($server_list->{$list}) eq 'ARRAY');
        for my $server (@{ $server_list->{$list}})
        {
            my $ip = CLI_Utils::resolveip($server);
            unless ($ip =~ /^127\.0\.0\./)
            {
                $servers{$server}++;
            }
        }
    }
    my $tungsten_home=$options->{user_values}{CONTINUENT_ROOT} ;
    my $MYSQL = "mysql -u $user_values->{DATASOURCE_USER} -p$user_values->{DATASOURCE_PASSWORD} -P$user_values->{DATASOURCE_PORT}";
    #
    # The uninstall commands will be dumped into a shell script, which will be executed when ready
    #
    my $current_recipe_uninstall = abs_path("./cookbook/current_recipe_uninstall.sh");
    open my $FH, '>', $current_recipe_uninstall
        or die "can't open $current_recipe_uninstall";
    my $manager_count =0;
    my $what_uninstaller_does =
                   "'uninstall-cluster' is a potentially damaging operation.\n"
                 . "This command will stop the cluster software in all servers\n"
                 . "and REMOVE ALL THE CONTENTS from $options->{user_values}{CONTINUENT_ROOT}.\n"
                 . "*** It will also REMOVE ALL DATABASE CONTENTS in all servers. *** \n"
                 . "If this is what you want, either set the variable I_WANT_TO_UNINSTALL \n"
                 . "or answer 'y' to the question below\n"
                 . "Alternatively, have a look at $current_recipe_uninstall and customize it to your needs.\n"
                 . "----\n"
                 . "A safer way of uninstalling the cluster can be achieved with \n"
                 . "    ./tools/tpm uninstall \n"
                 ;
 
    my $echo_message = $what_uninstaller_does;
    $echo_message =~ s/(.+)/echo "$1"/g;
    print $FH "#!/bin/bash\n",
              $echo_message,
              "\n",
              qq(while [ -z "\$I_WANT_TO_UNINSTALL" ] ; do\n),
              "    read -p 'Do you wish to uninstall this cluster? [y/n] ' yn \n",
              "    case \$yn in \n",
              "        [Yy]* ) I_WANT_TO_UNINSTALL=YES;; \n",
              "        [Nn]* ) exit;;\n",
              "        * ) echo 'Please answer (y) or (n).';;\n",
              "    esac\n",
              "done\n";

    print $FH "echo 'running uninstall commands in parallel. Please wait ...'\n";
    #
    # Creates the uninstall commands for each server
    #
    for my $server (sort keys %servers)
    {
        my $uninstall_commands =
            qq($SSH $SSH_USER\@$server "$tungsten_home/tungsten/cluster-home/bin/stopall; rm -rf $tungsten_home/*" > /tmp/uninstall_$server.log 2>&1 &\n)
          . qq($SSH $SSH_USER\@$server "rm -f \$HOME/$options->{shortcut_dir}"\n)
          . qq($SSH $SSH_USER\@$server "rm -f \$HOME/$continuent_tungsten_staging_directory"\n)
          . qq($SSH $SSH_USER\@$server "if [ -f  \$HOME/bin/tungsten_tools_marker ] ; then  rm -f \$HOME/bin/{cctrl,trepctl,connector,manager,replicator,thl} ; fi "\n)
          . qq($SSH $SSH_USER\@$server "if [ -f  \$HOME/bin/tungsten_tools_marker ] ; then  rm -f \$HOME/bin/show_{connector,manager,replicator}_log ; fi "\n)
          . qq($SSH $SSH_USER\@$server "if [ -f  \$HOME/bin/tungsten_tools_marker ] ; then  rm -f \$HOME/bin/edit_{connector,manager,replicator}_conf ; fi "\n)
          . qq($SSH $SSH_USER\@$server "if [ -f  \$HOME/bin/tungsten_tools_marker ] ; then  rm -f \$HOME/bin/tungsten_tools_marker ; fi "\n)
          # . qq($SSH $SSH_USER\@$server "rm -rf $tungsten_home/*"\n)
          ;
        if ($CLI_Utils::VERBOSE && !$options->{dry_run} )
        {
            print $uninstall_commands unless $just_prepare;
        }
        print $FH $uninstall_commands;

        #
        # Checks that there is a manager for each server
        #
        my $manager = "$user_values->{CONTINUENT_ROOT}/tungsten/tungsten-manager/bin/manager";
        # my $manager_exists = get_remote_result($server, "if [ -x $manager ] ; then echo OK ; else echo no; fi");
        # if ( $manager_exists && ($manager_exists eq 'OK'))
        if (remote_file_test($server, $manager, '-x'))
        {
            $manager_count++;
        }
    }
    print $FH qq(wait \n);
    for my $server (sort keys %servers)
    {
        print $FH "cat /tmp/uninstall_$server.log \n" ;

        my $boot_script=$user_values->{DATASOURCE_BOOT_SCRIPT};
        #my $mysql_not_running = get_remote_result($server,  "sudo $boot_script status |grep ERROR");
        #if ($mysql_not_running && ($mysql_not_running =~ /ERROR|FAILED|not running/i))
        #{
        print $FH qq[MYSQL_NOT_RUNNING=\$(ssh $SSH_USER\@$server sudo $boot_script status | grep 'ERROR\\|FAILED\\|not running')\n],
                  qq(if [ -n "\$MYSQL_NOT_RUNNING" ]\n),
                  qq(then \n),
                  qq(    $SSH $SSH_USER\@$server sudo $boot_script start\n),
                  qq(fi\n);
        #}
        print $FH 
            qq[for SCHEMA in \$($MYSQL -h $server -NB -e "show schemas like 'tungsten%\'")\n]
          . qq[do\n]
          .     qq($MYSQL -h $server -e "drop schema if exists \$SCHEMA"\n)
          . qq[done\n]
          . qq($MYSQL -h $server -e 'drop schema if exists tungsten; drop schema if exists evaluator;'\n)
          . qq($MYSQL -h $server -e 'drop schema if exists test; create schema test; reset master'\n)
          . qq($MYSQL -h $server -e 'set global read_only=0'\n);
    }

    close $FH;
    chmod 0755, $current_recipe_uninstall;
    if ($just_prepare)
    {
        return;
    }
    #
    # If no managers were found in the previous step
    # the uninstall doesn't run
    #
    if (($manager_count == 0) && ! $options->{force_uninstall})
    {
        warn "No managers found in servers @{[keys %servers]}\n";
        warn "Perhaps an uninstall was already performed?\n";
        warn "Use --force-uninstall to proceed anyway\n";
        exit ;
    }
    elsif ( $manager_count < scalar(keys %servers))
    {
        my $expected_managers = scalar(keys %servers);
        warn "Found only $manager_count managers instead of $expected_managers\n"; 
        warn "Running the uninstall anyway. You may see errors\n";
    }
    
    #
    # uninstall (or its dry run) is performed here.
    #
    my $command = $current_recipe_uninstall;
    if ($options->{dry_run})
    {
        $command = "cat $current_recipe_uninstall" ;
    }
    my $result = system $command;
    if ($result)
    {
        die "error running '$command' ($!)\n";
    }
    exit if $options->{dry_run};
}


###########################################################
#
# Runs a command in a remote server and returns the result
#
###########################################################
sub get_remote_result
{
    use Carp;
    my ($server, $cmd) = @_;
    unless ($server && $cmd)
    {
        croak "undefined server or cmd\n";
    }
    if ($CLI_Utils::DEBUG > 2)
    {
        print qq(#i $SSH -q $SSH_USER\@$server "$cmd"\n);
    }
    if ($logging)
    {
        print_log (qq(#i $SSH -q $SSH_USER\@$server "$cmd"\n), 1);
    }
    if ($demoing)
    {
        print "server: $server -> $cmd\n";
    }
    my $result = qx($SSH -q $SSH_USER\@$server "$cmd");
    return unless $result;
    if ($CLI_Utils::DEBUG > 2)
    {
        print qq(#o << $result>>\n);
    }
    chomp $result;
    if ($logging)
    {
        print_log( qq(#o << $result>>\n));
    }
    if ($demoing)
    {
        print "\n$result\n";
    }
    return $result;
}

###########################################################
# Runs a command in the local server and returns the result
###########################################################
sub get_local_result
{
    my ($cmd) = @_;
    if ($CLI_Utils::DEBUG > 2)
    {
        print qq(#i "$cmd"\n);
    }
    if ($logging)
    {
        print_log (qq(#i "$cmd"\n), 1);
    }
    if ($demoing)
    {
        print "\$ $cmd\n";
    }

    my $result = qx($cmd);
    return unless $result;
    if ($CLI_Utils::DEBUG > 2)
    {
        print qq(#o << $result>>\n);
    }
    chomp $result;
    if ($logging)
    {
        print_log( qq(#o << $result>>\n));
    }
    if ($demoing)
    {
        print "\n$result\n";
    }
    return $result;
}

######################################################
# ok
# 
# tests a given condition, and displays 'ok' for truth
# or 'not ok' for falsehood.
#
######################################################
sub ok ($$)
{
    my ($probe, $msg) = @_;
    $test_outcome{all}++;
    my $status='ok';
    if ($probe)
    {
        $test_outcome{pass}++;
    }
    else
    {
        $status= 'not ok';
        $test_outcome{fail}++;
        unless ($skip_status_in_log)
        {
            get_cluster_status($current_options, 'log_status');
        }
    }
    print "$status - $msg\n";
    if (!$probe && $CLI_Utils::VERBOSE)
    {
        my ($package, $filename, $line) = caller;
        print "#DEBUG-> Called from $package:$filename:$line\n";
    }
    if ($logging)
    {
        print_log( "$status - $msg\n");
    }
    if ($demoing)
    {
        wait_for_input();
    }
    return $probe;
}

sub print_log
{
    my ($msg, $ts) = @_;
    return unless $log_file;
    my $mode = '>>';
    unless (defined $msg)
    {
        $mode = '>';
    }
    open my $FH, $mode, $log_file
        or return;
    if ($ts)
    {
        print $FH scalar(localtime), "\n";
    }
    if ($msg)
    {
        print $FH $msg;
        unless ($msg =~ /\n\Z/)
        {
            print $FH "\n";
        }
    }
    close $FH;
}

sub trap_int
{
    $demoing =1;

}

sub catch_sysint
{
    if ($demo_delay)
    {
        $demo_delay = 0;
    }
    else
    {
        $demoing=1;
        #exit;
    }
}

sub wait_for_input
{
    return unless $demoing;
    $|=1;
    if ($first_demo_prompt && (! $demo_delay))
    {
        print "# DEMO MODE. Press ENTER to continue, or enter 'h'+ENTER for help\n";
        $first_demo_prompt =0;
    }
    if ($demo_delay)
    {
        for ( 0 .. $demo_delay)
        {
            last unless $demo_delay;
            sleep 1;
            print ".";
        }
        print "\n";
    }
    else
    {
        print "#(D)>> ";
        my $in = <>;
        chomp $in;
        if ($in)
        {
            if ($in eq  'q')
            {
                print "User interruption - Terminating ...\n";
                warn "Depending when the interruption was requested, the cluster may not be in operational state\n";
                exit 1;
            }
            elsif ($in =~ /^d:(\d+)$/)
            {
                $demo_delay = $1;
                print "Entering delayed mode. Waiting $demo_delay seconds between steps\n";
            }
            elsif ($in eq  'c')
            {
                print "Demo mode cancelled - continuing without further interruption\n";
                $demoing =0;
            }
            elsif ($in eq  's')
            {
                print "Getting cluster status ... \n";
                $demoing =0;
                print get_cluster_status($current_options);
                $demoing =1;
                wait_for_input();
            }
            elsif (($in =~  /cctrl\s+(\S+)\s+"([^"]+)"\s+"([^"]+)"/) 
                or ($in =~  /cctrl\s+(\S+)\s+'([^']+)'\s+'([^']+)'/))
            {
                my $server = $1;
                my $args = $2;
                my $command = $3;
                print "Running cctrl command  ... \n";
                $demoing =0;
                print run_cctrl($server, $args, $command), "\n";
                $demoing = 1;
                wait_for_input();
            }
            elsif ($in eq  '$')
            {
                print "Shell requested.\n";
                $ENV{PS1} = 'type "exit" to return to tungsten-cookbook\n$ ';
                system($ENV{SHELL} || '/bin/sh');
                wait_for_input();
            }
            elsif ($in eq  'h')
            {
                print "Allowed:\n",
                      "ENTER    -> continue to next step\n",
                      "c        -> continue till the end of the program without further interruptions\n",
                      "d:N      -> continue with delay of N seconds between steps\n",
                      "s        -> Prints a full cluster Status\n",
                      qq(cctrl SERVER "cctrl arguments" "command" -> runs a cctrl command. (quotes mandatory!)\n),
                      "\$       -> runs a shell \n",
                      "q        -> terminate the program immediately\n",
                      "h        -> show this help\n";
                wait_for_input();
            }
        }
    }
}

sub check_evaluator
{
    my $evaluator_pid = qx/ps aux | grep Evaluator| grep -v "grep Evaluator"|awk '{print \$2}'/;
    if ($evaluator_pid)
    {
        my @pids = grep {$_} split /\n/, $evaluator_pid;
        if (@pids > 1)
        {
            die "Found more than one evaluator PID\n";
            # return;
        }
        return $pids[0];
    }
    return;
}

sub stop_load
{
    my $tmp_dir= write_to_tmp(undef,undef);
    my $evaluator_pid = "$tmp_dir/evaluator.pid";
    unless (-f $evaluator_pid)
    {
        warn "could not find $evaluator_pid\n";
        return;
    }
    my ($pid) = CLI_Utils::slurp($evaluator_pid);
    chomp $pid;
    if ($CLI_Utils::VERBOSE)
    {
        print "# Stopping evaluator at pid $pid\n" ;
    }
    kill 15, $pid;
    unlink $evaluator_pid;
}

sub start_evaluator
{
    my ($options) = @_;
    my $user_values = $options->{user_values};
   
    my %evaluator_normal = (
        testDuration => 1800,
        updates  => 15,
        deletes => 5,
        inserts => 10,
        readsize => 1000,
        rampUpInterval => 5,
        rampUpIncrement => 2,
    ); 
    my %evaluator_fast = (
        testDuration => 1800,
        updates  => 1,
        deletes => 1,
        inserts => 3,
        readsize => 2,
        rampUpInterval => 0,
        rampUpIncrement => 0,
    ); 
    my %evaluator = %evaluator_normal;
    if ($options->{fast_load})
    {
        %evaluator = %evaluator_fast;
    }
    my $xml_text=<<EVALUATOR_EOF;
    <!DOCTYPE EvaluatorConfiguration SYSTEM "file://someplace/evaluator.dtd">
    <EvaluatorConfiguration 
        name="mysql" 
        testDuration="$evaluator{testDuration}"
        autoCommit="true" 
        statusInterval="2" 
        htmlFile="mysqlResults.html" >
        <Database driver="com.mysql.jdbc.Driver"        
            url="jdbc:mysql://127.0.0.1:$user_values->{APPLICATION_PORT}/evaluator?createDatabaseIfNotExist=true"
            user="$user_values->{APPLICATION_USER}"
            password="$user_values->{APPLICATION_PASSWORD}"/> 
         
        <TableGroup 
            name="tbl" 
            size="100">
            <ThreadGroup 
                name="A" 
                threadCount="10" 
                thinkTime="1"
                updates="$evaluator{updates}" 
                deletes="$evaluator{deletes}" 
                inserts="$evaluator{inserts}" 
                readSize="$evaluator{readsize}"
                rampUpInterval="$evaluator{rampUpInterval}" 
                rampUpIncrement="$evaluator{rampUpIncrement}"/>
        </TableGroup>
    </EvaluatorConfiguration>

EVALUATOR_EOF
    
    my $evaluator_path = "$user_values->{CONTINUENT_ROOT}/tungsten/bristlecone/bin/evaluator.sh";
    unless ( -x $evaluator_path)
    {
        warn "# Could not find the evaluator launcher at '$evaluator_path'\n";
        return ;
    }
    my $evaluator_running = check_evaluator();
    my $must_wait_for_cleanup =0;
    my $MYSQL= sprintf('mysql -h 127.0.0.1 -u%s -p%s -P%d ',
        $user_values->{APPLICATION_USER},
        $user_values->{APPLICATION_PASSWORD},
        $user_values->{APPLICATION_PORT} 
    );

    if ($evaluator_running)
    {
        unless ($evaluator_running == -1)
        {
            warn "# Evaluator already running with pid $evaluator_running. Not started.\n";
        }
        return;
    }
    else
    {
        # evaluator not running. Checking for remnants of database 
        my $result = get_local_result(qq[$MYSQL -BN -e 'select count(*) from information_schema.tables where table_schema="evaluator" and table_name ="tbl3"' ]);
        if ($result)
        {
            $must_wait_for_cleanup = 1;
        }
    
    }
    my $child_pid = fork;
    if ($child_pid)
    {
        if ($must_wait_for_cleanup)
        {
            sleep 5;
        }
        my $timeout = 60;
        my $elapsed = 0;
        my $evaluator_pid;
        while ($elapsed < $timeout)
        {
            $evaluator_pid = check_evaluator();
            if (defined $evaluator_pid && $evaluator_pid == -1)
            {
                return;
            }
            last if $evaluator_pid;
            sleep 1;
            $elapsed++;
        }
        unless ($evaluator_pid)
        {
            warn "could not determine evaluator pid \n";
            return;
        }
        $elapsed = 0;
        while ($elapsed < $timeout)
        {
            my $result = get_local_result(qq[$MYSQL -BN -e 'select count(*) from information_schema.tables where table_schema="evaluator" and table_name ="tbl3"' ]);
            if ($result)
            {
                $result = get_local_result(qq[$MYSQL -BN -e 'select count(*) from evaluator.tbl3' ]);
            }
            # print "## ($elapsed) $result\n";
            if ($result && ($result > 1000))
            {
                write_to_tmp('evaluator.pid',"$evaluator_pid\n");
                return $evaluator_pid;
            }
            sleep 1;
            $elapsed++;
        }
    }
    else
    {
        # inside the child process
        my $evaluator_xml = 'evaluator.xml';
        my $tmpdir = write_to_tmp($evaluator_xml, $xml_text);
        # exec "screen -d -m -S evaluator $evaluator_path $evaluator_xml";
        if ($CLI_Utils::VERBOSE)
        {
            print "# $evaluator_path $tmpdir/$evaluator_xml > $tmpdir/evaluator.log \n";
        }
        exec "$evaluator_path $tmpdir/$evaluator_xml > $tmpdir/evaluator.log 2>&1";
    }

    return ;
}

sub write_to_tmp
{
    my ($fname, $text) = @_;
    my $tmpdir = $ENV{TMPDIR} || $ENV{TEMPDIR}  || '/tmp';
    die "can't find temporary directory $tmpdir \n" unless -d $tmpdir;
    unless ($fname)
    {
        return $tmpdir;
    }
    my $full_fname = $tmpdir . '/' . $fname;
    open my $FH, '>', $full_fname
        or die "can't create $full_fname ($!)\n";
    print $FH $text;
    close $FH;
    return $tmpdir;
}

__END__

=head1 NAME
Tungsten Cookbook Helper (TCH)

This tool helps you install Tungsten clusters, perform tests, and eventually uninstall the cluster

=head1 SYNOPSIS

=over 3

=item 1.
edit USER_VALUES.sh, 

with the values from the cluster you wish to install.

=item 2. 
Try a dry-run

  ./cookbook/tungsten-cookbook --dry-run std

=item 3. 
Install and test

  ./cookbook/tungsten-cookbook --verbose --run-test std

=item 4. 
Run more tests, without installing again

  ./cookbook/tungsten-cookbook --verbose --run-test --tests=all --skip-install std

=item 5. 
Remove the cluster, to try another recipe

  ./cookbook/tungsten-cookbook --uninstall-cluster std

=back

=head1 Overview

The Tungsten Cookbook Helper is a tool that helps users to handle cookbook templates.

Using the TCH, you can list, show, run, and test cookbook recipes.


The TCH main features are:

=over 3

=item *

listing cookbook recipes with their description;

=item *

showing individual recipes;

=item *

perform a dry-run of the recipe with user values;

=item *

run the recipe, with optional verbose e/o debug information;

=item *

run a simple smoke test after the recipe execution, to check the installation health.

=item *

run additional tests after the main tests.

=item *

run extensive smoke tests, to try Tungsten basic features.

=back

The main purpose of this tool is to keep the recipe as clean as possible for the user, keeping the ancillary code inside the cookbook Helper.


Additional features, which keep the template simple:

=over 3

=item *

listing the template description, if the template contains a line saying "template_name : description";

=item *

automatically skipping template lines containing variables that the user has not specified. This feature allows us to make a template with non-necessary lines, which the user can skip by simply omitting to define a variable for that line.

=back

=head1 TCH files

The Tungsten cookbook Helper uses two kinds of files:

=over 3

=item *

.tmpl, which are the bare templates

=item *

USER_VALUES*.sh, which contain the variables inserted by users

=back

=head2 Sample contents

B<std.tmpl>

 # std : install a single Continuent Tungsten cluster
  
 tools/tpm install $DS_NAME \
    --datasource-port=$DATASOURCE_PORT \
    --home-directory=$CONTINUENT_ROOT \
    --user=$USER \
    --datasource-user=$DATASOURCE_USER \
    --datasource-password=$DATASOURCE_PASSWORD \
    --dataservice-hosts=$MASTER,$SLAVES \
    --dataservice-connectors=$CONNECTORS \
    --dataservice-master-host=$MASTER \
    --mysql-connectorj-path=$CONNECTORJ \
    --dataservice-witnesses=$WITNESS \
    --datasource-boot-script=$DATASOURCE_BOOT_SCRIPT \
    --datasource-log-directory=$MYSQL_BINARY_LOG_DIRECTORY \
    --datasource-mysql-conf=$MYSQL_CONF \
    --root-command-prefix=$ROOT_COMMAND \
    --profile-script=$PROFILE_SCRIPT \
    $MORE_OPTIONS \
    $START_OPTION

    
B<sor.tmpl>

 # sor : install a System of Records, master/relay Continuent Tungsten cluster
 
 tools/tpm configure defaults --reset \
    --datasource-port=$DATASOURCE_PORT \
    --home-directory=$CONTINUENT_ROOT \
    --user=$USER \
    --datasource-user=$DATASOURCE_USER \
    --datasource-password=$DATASOURCE_PASSWORD \
    --datasource-boot-script=$DATASOURCE_BOOT_SCRIPT \
    --datasource-log-directory=$MYSQL_BINARY_LOG_DIRECTORY \
    --datasource-mysql-conf=$MYSQL_CONF \
    --mysql-connectorj-path=$CONNECTORJ \
    --root-command-prefix=$ROOT_COMMAND \
    --profile-script=$PROFILE_SCRIPT \
    $MORE_OPTIONS \
    $START_OPTION  
 
 tools/tpm configure $DS_NAME1 \
    --dataservice-hosts=$MASTER1,$SLAVES1 \
    --dataservice-connectors=$CONNECTORS1 \
    --dataservice-master-host=$MASTER1 \
    --dataservice-witnesses=$WITNESS1
 
 tools/tpm configure $DS_NAME2 \
    --dataservice-hosts=$MASTER2,$SLAVES2 \
    --dataservice-relay-enabled=true \
    --dataservice-relay-source=$DS_NAME1 \
    --dataservice-connectors=$CONNECTORS2 \
    --dataservice-master-host=$MASTER2 \
    --dataservice-witnesses=$WITNESS2
 
 tools/tpm configure $COMPOSITE_DS \
    --dataservice-composite-datasources=$DS_NAME1,$DS_NAME2
 
 tools/tpm install $COMPOSITE_DS

B<USER_VALUES.sh>

  #!/bin/bash
  
  ##############################
  # server list
  ##############################
  
  NODE1=
  NODE2=
  NODE3=
  NODE4=
  # the witness server should be a server outside the cluster
  WITNESS=
  
  ##############################
  # Values needed by all recipes
  ##############################
  export CONTINUENT_ROOT=/opt/continuent
  export USER=tungsten
  export CONNECTORJ=/opt/continuent/mysql-connector-java-5.1.16-bin.jar
  export DATASOURCE_USER=tungsten
  export DATASOURCE_PASSWORD=secret
  export DATASOURCE_PORT=3306
  export DATASOURCE_BOOT_SCRIPT=/etc/init.d/mysql 
  export MYSQL_BINARY_LOG_DIRECTORY=/var/lib/mysql
  export MYSQL_CONF=/etc/my.cnf
  export START_OPTION=--start-and-report
  export ROOT_COMMAND=true
  export CONNECTOR_DIRECT_RW=127.0.0.1
  export CONNECTOR_DIRECT_RO=127.0.0.2
  # export PROFILE_SCRIPT="~/.bashrc"
  
  ##############################
  # Values needed by std recipes
  ##############################
  export DS_NAME=chicago
  export MASTER=$NODE1
  export SLAVES=$NODE2,$NODE3
  export CONNECTORS=$NODE2,$NODE4
  
  ##############################
  # Values needed by sor recipes
  ##############################
  export DS_NAME1=europe
  export MASTER1=$NODE1
  export SLAVES1=$NODE2
  export WITNESS1=$WITNESS
  export CONNECTORS1=$NODE1,$NODE2
  
  export DS_NAME2=asia
  export MASTER2=$NODE3
  export SLAVES2=$NODE4
  export WITNESS2=$WITNESS
  export CONNECTORS2=$NODE3,$NODE4
  
  export COMPOSITE_DS=world

=head1 Getting started.

The TCH is shipped together with the Tungsten-Enterprise tarball. In the directory ./cookbook you will find the executable, some templates (.tmpl), and a few USER_VALUES.* files.

To use any of the recipes, you need to choose which cluster you want to install, and then edit the configuration files.

=over 3

=item 1
How many servers.

If You have 3 or 4 server, the default USER_VALUES.sh will do. If you have only two, you will use the specially built 2-NODES-USER_VALUES.sh. For an 8 server deployment that creates a 3 sites disaster-recovery deployment, you will need USER_VALUES3.sh.

=item 2
Which topology.

There are two ways of installing Tungsten. Either as a single standard cluster, for which you will choose the 'std' template, or the disaster recovery deployment,for which you will choose the 'sor' template. If you have only two servers, then the std template is your only choice.

If you aent to use the 'sor3' template, you have also to indicate the appropriate USER VALUES:

  ./cookbook/tungsten-cookbook --values-file=./cookbook/USER_VALUES3.sh  --verbose sor3

There are two additional topologies that you can use instead of 'std' or 'sor'. They are called 'std_direct_connectors' and 'sor_direct_connectors'. The only difference between these two recipes and their simple counterpart is that they implement a direct connection to the master and one to the slaves.

After the installation, in each connector host, invoking a connector with '--host=127.0.0.1 -P 9999' will get the master, and invoking it with '--host=127.0.0.2 -P 9999', will get a slave.

=item 3
Enter user variables.

The template should stay unchanged. You should edit the file USER_VALUES.sh with your basic information. Unless you have special needs, in this file you should only insert the host names of the servers where you want to install Tungsten. 
For example inside USER_VALUES.sh you will find these lines:

  ##############################
  # server list
  ##############################
  
  NODE1=
  NODE2=
  NODE3=
  NODE4=
  # the witness server should be a server outside the cluster
  WITNESS=
  
You should change it to:

  ##############################
  # server list
  ##############################
  
  NODE1=myfirst.example.com
  NODE2=mysecond.example.com
  NODE3=mythird.example.com
  NODE4=myfourth.example.com
  # the witness server should be a server outside the cluster
  WITNESS=someotherplace.example.com

NODE1 will be the master. NODE2 and NODE3 will get a slave each, and a connector will be installed on NODE2 and NODE4.

If you have only 3 nodes, you should also change all instances of NODE4 to NODE3. You cannot install a 'sor' deployment with less than 4 servers. If you use only 3 servers you should truncate USER_VALUES.sh after the line that says "Values needed by sor recipes."

=item 4
install and test.

After the file USER_VALUES.sh has been modified, you can show the recipe on screen, to see if it is what you expect:

  ./cookbook/tungsten-cookbook --dry-run std

If you don't get any error, and are satisfied with what you see, you can then run the installer

  ./cookbook/tungsten-cookbook --verbose --run-test --log std

or

  ./cookbook/tungsten-cookbook --verbose --run-test --log --tests=all std

You can, however, run the recipe directly. When you run tungsten-cookbook, the recipe will be saved to a file named 'current_recipe.sh'. This is the file that tungsten-cookbook runs to get the installation done. If you don't want to run the tests, or you have any trouble running the recipe from tungsten-cookbook, you can run 

  ./current_recipe.sh

To repeat the test without reinstalling, use the --skip-install option.

  ./cookbook/tungsten-cookbook --verbose --run-test --log --skip-install --tests=all std

=back

=head1 Tests with load and additional checks

=head2 Loads

The TCH can create some load for the cluster, in order to make the tests more realistic.
If you use C<--start-load>, the TCH will start Bristlecone before running the tests. Likewise, C<--stop-load> will stop Bristlecone at the end of the tests.

=head2 Backups

Some of the tests can detect when a regular way of recovery fails, and attempt a backup+restore operation to put a host back in operation. If you don't give any option, the system assumes that your backups are saved to a shared folder (e.g. NFS), and it will simply make sure that the files are available to all nodes before attempting a restore. But if you don't have a shared folder, you can task the TCH itself to copy the backup artifacts, using the option C<--copy-backups>. When you ask for this option, the backups are copied to the corresponding backup folder in all servers, and then used with a "restore" operation.

=head2 Testing 2-nodes

When testing with 2 nodes, there is a potential problem in recovery. When your master has failed, and the slave has taken over, you want to recover the failed master as a slave. Normally this should succeed, but if the failure happened under heavy load, sometimes the failed master can't come back online because of conflicts. In this case, the Tungsten cluster manager suggests  using backup+restore to recover the node. The problem is, with only one master available, a backup is an operation that would require a service interruption. And anyway, this operation is not handled by the cluster manager.
To help you test in this case where thera are no additional slaves to take a backup from, there is a handy option C<--backup-first>. When you use it, the TCH will run a backup before any test, and therefore a backup will be available, should one of the recovery options fail.


=head2 Getting the cluster status on screen and in the logs

When you have activated logs with C<--log>, you get the command used by the test helper to check the cluster, and its output. Sometimes, this is enough, and sometimes, you need more information. if you want more detail on what is the status of the cluster during the tests, you can ask for C<--log-cluster-status>, which will insert in the logs a full status of the cluster.
And if you want such status on screen, after a test, or instead of a test, you can run the TCH with C<--cluster-status>

   ./tungsten-cookbook --cluster-status sor

This command will print the status of every data service, the list of member, the list of resources, and the status of routers. If you specify C<--verbose>, the information will be even more detailed.

You can get a cluster status also from C<Demo mode>.


=head1 Demo mode

The TCH can run a test unattended. Most of the times, this is what you want to do, but sometimes you would like to have more control on the process. For example, you would like to stop agter a given action, see what is happening, perhaps show the output of the operation, and then continue. For such cases, there is the demo mode, which is activated by asking C<--demo> on the command line.
When running in demo mode, the TCH starts running the smoke test, if required also the replication test, and then  stops executing after the first task.
For example, if you asked for the switch test, you would see something like this:

 server: qa.te1.continuent.com -> echo switch to qa.te2.continuent.com | /opt/continuent/sor_test/tungsten/tungsten-manager/bin/cctrl
 
 Tungsten Enterprise 1.5.2 build 90
 connect to 'sjc@qa.te1.continuent.com'
 sjc: session established
 [LOGICAL] /sjc > switch to qa.te2.continuent.com
 SELECTED SLAVE: qa.te2.continuent.com@sjc
 PURGE REMAINING ACTIVE SESSIONS ON CURRENT MASTER 'qa.te1.continuent.com@sjc'
 PURGED A TOTAL OF 0 ACTIVE SESSIONS ON MASTER 'qa.te1.continuent.com@sjc'
 FLUSH TRANSACTIONS ON CURRENT MASTER 'qa.te1.continuent.com@sjc'
 PUT THE NEW MASTER 'qa.te2.continuent.com@sjc' ONLINE
 PUT THE PRIOR MASTER 'qa.te1.continuent.com@sjc' ONLINE AS A SLAVE
 RECONFIGURING RELAY 'qa.te3.continuent.com@nyc' TO POINT TO NEW MASTER 'qa.te2.continuent.com@sjc'
 SWITCH TO 'qa.te2.continuent.com@sjc' WAS SUCCESSFUL
 [LOGICAL] /sjc > 
 Exiting...
 ok - SWITCH to qa.te2.continuent.com was successful 
 # DEMO MODE. Press ENTER to continue, or enter 'h'+ENTER for help
 #(D)>> 

The first line is the command that was executed. Then follows the output of such command, and at the end there is the evaluation of the command output, resulting in "ok" or "not ok".
After that, you get a prompt "#(D)>>", which tells you that are in Demo mode. At this point, you can simply hit ENTER to the next step, or have a look at the help:

  #(D)>> h 
  Allowed:
  ENTER    -> continue to next step
  c        -> continue till the end of the program without further interruptions
  d:N      -> continue with delay of N seconds between steps
  s        -> Prints a full cluster Status
  cctrl SERVER "cctrl arguments" "command" -> runs a cctrl command. (quotes mandatory!)
  $       -> runs a shell 
  q        -> terminate the program immediately
  h        -> show this help
  #(D)>> 

As you see, there are several things that can be done. Continuing to the next step is the most immediate. But you may also decide to exit demo mode and continuing the test without further interruption (Press "c" before ENTER).

Another useful option is to switch to delayed demo. You canget to this behavior using C<--demo-delay=N>, where N is the number of seconds that the demo will stop before running the next step. In this way, you will have an unattended demo, which is almost like looking at the logs while they are written. 
During the pause, you will see one dot ('.') being printed on screen for each second of the delay.
You can exit from delayed demo. During the display of the dots, if you press C<CTRL+C>, the delay will be canceled and you will return to regular demo.

Other actions during demo mode are :

=over 3

=item *
Running a shell ('$'). You can get a shell prompt and run whichever command you want. When you exit the shell, you resume the test in demo mode.

=item *
Getting a full status of the cluster ('s'). This command prints the same information that you would get with C<--cluster-status>.

=item *
Running a cctrl command. This requires some more skills, but it is extremely handy. The syntax is
   cctrl SERVER "options" "command"

Where SERVER is any node where a manager was installed, and "options" is any cctrl command line options, such as "-expert -multi". For example

  cctrl qa.te1.continuent.com "-multi" "use europe; cluster heartbeat"

Notice that quoting is mandatory, even if the option or the command is a single word.

=item *
Finally, you can quit the TCH completely. This option is potentially dangerous, as you could leave the cluster in an unstable condition.

=back

=head1 Sample runs

=head2 The help

 $ ./tungsten-cookbook --help --verbose

 The Cookbook Helper
 version 1.0.7
 (C) Continuent, Inc, 2012
 Syntax: cookbook [options] [recipe] 
     -l --list                           Show existing cookbook recipes
     -s --show                           Show the recipe
     --dry-run                           Only show the recipe, without running it
     --run-test                          If a test exists for this recipe, run it
     --tests = name                      run additional tests
                                         (Allowed: {all|cfailover|crecover|cswitch|failover|recover|replication|switch})
     --more-options = name               Add more options to the chosen recipe
     --skip-install                      Do not run the installation (useful for running the test several times)
     --values-file = name                Changes the file containing the user's values (USER_VALUES.sh)
                                         (Must have)
     --fail-on-undefined                 Fails if lines contain undefined values (default: skips them)
     --cookbook-directory = name         Changes the file containing the user's values (.)
     --uninstall-cluster                 Removes a cluster deployed with the given recipe
                                         [WARNING] : this option will delete files and remove DB schemas 
     --skip-vars = name                  Skips given variables 
     --force-uninstall                   Forces the removal of a cluster even if the preliminary check fails
     --collect-logs                      Collect the manager, replicator, and connector logs of all nodes into a tarball
     --debug = number                    Increases the amount of information given during execution.
                                         Use --debug=3 to see the output of every command given
     --log                               Saves all test commands and their output to a given file
     --log-file = name                   Define the file name for logging (requires --log) (tungsten-cookbook.log)
     --cctrl-options = name              Gets options that should be passed to cctrl
     --verbose                           Show more information during installation and help 
     -man --manual                       Display the program manual
     -v --version                        Show ./tungsten-cookbook-1.0.7 version and exit 
     --display-options                   Show all the options without running the program
     -h --help                           Display this help

=head2    Showing a recipe

 ./tungsten-cookbook --show std
 # std : install a single Continuent Tungsten cluster
 
 tools/tpm install $DS_NAME \
    --datasource-port=$DATASOURCE_PORT \
    --home-directory=$CONTINUENT_ROOT \
    --user=$USER \
    --datasource-user=$DATASOURCE_USER \
    --datasource-password=$DATASOURCE_PASSWORD \
    --dataservice-hosts=$MASTER,$SLAVES \
    --dataservice-connectors=$CONNECTORS \
    --dataservice-master-host=$MASTER \
    --mysql-connectorj-path=$CONNECTORJ \
    --dataservice-witnesses=$WITNESS \
    --datasource-boot-script=$DATASOURCE_BOOT_SCRIPT \
    --datasource-log-directory=$MYSQL_BINARY_LOG_DIRECTORY \
    --profile-script=$PROFILE_SCRIPT \
    $MORE_OPTIONS \
    $START_OPTION

=head2 A dry run

 ./tungsten-cookbook --dry-run std --verbose
 # std : install a single Continuent Tungsten cluster
  
 tools/tpm install default \
    --datasource-port=3306 \
    --home-directory=/opt/continuent/test_std \
    --user=tungsten \
    --datasource-user=tungsten \
    --datasource-password=secret \
    --dataservice-hosts=qa.tx1.continuent.com,qa.tx2.continuent.com,qa.tx4.continuent.com,qa.tx8.continuent.com \
    --dataservice-connectors=qa.tx2.continuent.com,qa.tx3.continuent.com \
    --dataservice-master-host=qa.tx1.continuent.com \
    --mysql-connectorj-path=/opt/continuent/mysql-connector-java-5.1.16-bin.jar \
    --dataservice-witnesses=qa.tx7.continuent.com \
    --datasource-boot-script=/etc/init.d/mysql  \
    --datasource-log-directory=/var/lib/mysql \
    --profile-script="~/.bashrc" \
    --start-and-report
 
 # [SKIPPED]     $MORE_OPTIONS \


=head2 A simple (non verbose) run, with tests

 ./cookbook2/tungsten-cookbook  --run-test std
 [ ... lots of lines from the installer here]
 ok - manager exists on server qa.tx1.continuent.com
 ok - manager status: "Tungsten Manager Service is running (PID:17749)."
 ok - cctrl exists on server qa.tx1.continuent.com
 ok - there is an ONLINE master 
 ok - manager exists on server qa.tx2.continuent.com
 ok - manager status: "Tungsten Manager Service is running (PID:26179)."
 ok - cctrl exists on server qa.tx2.continuent.com
 ok - there is an ONLINE slave 
 ok - manager exists on server qa.tx4.continuent.com
 ok - manager status: "Tungsten Manager Service is running (PID:17490)."
 ok - cctrl exists on server qa.tx4.continuent.com
 ok - there is an ONLINE slave 
 ok - manager exists on server qa.tx8.continuent.com
 ok - manager status: "Tungsten Manager Service is running (PID:15438)."
 ok - cctrl exists on server qa.tx8.continuent.com
 ok - there is an ONLINE slave 
 ok - server qa.tx2.continuent.com - smartscale as expected: false
 ok - server qa.tx3.continuent.com - smartscale as expected: false
 
=head2 A real run, with verbose output, additional connector option, and test

 $./cookbook/tungsten-cookbook --verbose --run-test --tests=all sor
  
[ ... lots of lines from the installer here]
  
 #---
 #world:
 #  asia:
 #    connectors:
 #      - qa.tx3.continuent.com
 #      - qa.tx8.continuent.com
 #    relays:
 #      - qa.tx3.continuent.com
 #    slaves:
 #      - qa.tx8.continuent.com
 #  europe:
 #    connectors:
 #      - qa.tx1.continuent.com
 #      - qa.tx2.continuent.com
 #    masters:
 #      - qa.tx1.continuent.com
 #    slaves:
 #      - qa.tx2.continuent.com
 ok - manager exists on server qa.tx1.continuent.com
 ok - manager status: "Tungsten Manager Service is running (PID:8488)."
 ok - cctrl exists on server qa.tx1.continuent.com
 ok - there is an ONLINE master 
 ok - manager exists on server qa.tx2.continuent.com
 ok - manager status: "Tungsten Manager Service is running (PID:17992)."
 ok - cctrl exists on server qa.tx2.continuent.com
 ok - there is an ONLINE slave 
 ok - manager exists on server qa.tx8.continuent.com
 ok - manager status: "Tungsten Manager Service is running (PID:20826)."
 ok - cctrl exists on server qa.tx8.continuent.com
 ok - there is an ONLINE slave 
 ok - manager exists on server qa.tx3.continuent.com
 ok - manager status: "Tungsten Manager Service is running (PID:5818)."
 ok - cctrl exists on server qa.tx3.continuent.com
 ok - there is an ONLINE relay 
 ok - server qa.tx1.continuent.com - smartscale as expected: false
 ok - server qa.tx2.continuent.com - smartscale as expected: false
 ok - server qa.tx3.continuent.com - smartscale as expected: false
 ok - server qa.tx8.continuent.com - smartscale as expected: false
 ok - europe is the composite master
 ok - asia is a composite slave
 # replication test 
 ok - got SERVER ID for qa.tx1.continuent.com - 1100
 ok - master qa.tx1.continuent.com can create a schema
 ok - master qa.tx1.continuent.com can drop a table
 ok - master qa.tx1.continuent.com can create a table
 ok - master qa.tx1.continuent.com can insert a record
 ok - master seqno (4) is > 0
 ok - slave qa.tx2.continuent.com got tables from master 
 ok - slave qa.tx2.continuent.com can retrieve records from the master
 ok - server qa.tx2.continuent.com  seqno is greater or equal to 4
 ok - slave qa.tx8.continuent.com got tables from master 
 ok - slave qa.tx8.continuent.com can retrieve records from the master
 ok - server qa.tx8.continuent.com  seqno is greater or equal to 4
 ok - slave qa.tx3.continuent.com got tables from master 
 ok - slave qa.tx3.continuent.com can retrieve records from the master
 ok - server qa.tx3.continuent.com  seqno is greater or equal to 4
 ok - master qa.tx1.continuent.com can drop a table
 ok - slave qa.tx2.continuent.com can drop a table 
 ok - slave qa.tx8.continuent.com can drop a table 
 ok - slave qa.tx3.continuent.com can drop a table 
 # (asia) switch 
 ok - SWITCH to qa.tx8.continuent.com was successful 
 ok - SWITCH to qa.tx3.continuent.com was successful 
 # (asia) failover 
 ok - qa.tx3.continuent.com failed over to qa.tx8.continuent.com
 # (asia) recovery 
 ok - recovery of qa.tx3.continuent.com was successful 
 ok - SWITCH to qa.tx3.continuent.com was successful 
 # (europe) switch 
 ok - SWITCH to qa.tx2.continuent.com was successful 
 ok - SWITCH to qa.tx1.continuent.com was successful 
 # (europe) failover 
 ok - qa.tx1.continuent.com failed over to qa.tx2.continuent.com
 # (europe) recovery 
 ok - recovery of qa.tx1.continuent.com was successful 
 ok - SWITCH to qa.tx1.continuent.com was successful 
 # composite switch 
 ok - composite switch to asia was successful
 ok - asia is the composite master
 ok - europe is a composite slave
 ok - composite switch to europe was successful
 ok - europe is the composite master
 ok - asia is a composite slave
 # composite failover 
 ok - composite failover to asia was successful
 # composite recovery 
 ok - composite recovery of europe was successful
 ok - europe is now a composite online slave
 ok - qa.tx1.continuent.com is now online (relay)
 ok - qa.tx2.continuent.com is now online (slave)
 ok - composite switch to europe was successful
 ok - europe is the composite master
 ok - asia is a composite slave
 #tests:    65
 #pass :    65 ( 100%)
 #fail :     0 (   0%)

=head2 More tests

The tool understands the topology being installed, and if you use the --verbose option, it will print the deployment tree.
Using this information, there are more tests that can run:

  --tests=TEST_NAME

where TEST_NAME is one of the following: (You can use --tests more than once).
  replication
  switch
  failover
  recover
  contents

  cswitch (composite switch)
  cfailover (composite failover)
  crecover (composite recovery)

If you want to run all of them without listing the tests individually, you can say 

  --tests=all


When you run all the tests, the tool will run switches inside every cluster, then it will provoke a failover, and attempt a recovery. It will stop if any of these tests fails.
The composite tests will perform a switch between clusters, then a failover, and a recovery. The tool will handle the case where Tungsten recovers the whole cluster at once, and the case where a manual recovery of individual server is needed.

The "contents" test is a special one. To run it, you also need to start a load before the test. What happens is that a background application (Bristlecone, distributed with the same package that contains Tungsten) keeps sending transactions to the cluster using Tungsten Connector. If everything goes as expected, the connector will always send the transactions to the current master. At the end of all the tests, the TCH will stop Bristlecone, and check the table contents in all database servers, comparing record counts and table checksums. The "contents" test passes if all nodes have the same number of records and the same checksum.
The "contents" test requires --start-load.


Here is a sample run with a 3-site deployment

  ./cookbook/tungsten-cookbook --values-file=$PWD/cookbook/USER_VALUES3.sh \
      --verbose --run-test --skip-install --tests=all sor3
  ---
  world:
    america:
      connectors:
        - qa.tx7.continuent.com
        - qa.tx8.continuent.com
      relays:
        - qa.tx7.continuent.com
      slaves:
        - qa.tx8.continuent.com
    asia:
      connectors:
        - qa.tx4.continuent.com
        - qa.tx5.continuent.com
        - qa.tx6.continuent.com
      relays:
        - qa.tx4.continuent.com
      slaves:
        - qa.tx5.continuent.com
        - qa.tx6.continuent.com
    europe:
      connectors:
        - qa.tx1.continuent.com
        - qa.tx2.continuent.com
        - qa.tx3.continuent.com
      masters:
        - qa.tx1.continuent.com
      slaves:
        - qa.tx2.continuent.com
        - qa.tx3.continuent.com
  ok - manager exists on server qa.tx1.continuent.com
  ok - manager status: "Tungsten Manager Service is running (PID:5183)."
  ok - cctrl exists on server qa.tx1.continuent.com
  ok - there is an ONLINE master 
  ok - manager exists on server qa.tx2.continuent.com
  ok - manager status: "Tungsten Manager Service is running (PID:5185)."
  ok - cctrl exists on server qa.tx2.continuent.com
  ok - there is an ONLINE slave 
  ok - manager exists on server qa.tx3.continuent.com
  ok - manager status: "Tungsten Manager Service is running (PID:5418)."
  ok - cctrl exists on server qa.tx3.continuent.com
  ok - there is an ONLINE slave 
  ok - manager exists on server qa.tx5.continuent.com
  ok - manager status: "Tungsten Manager Service is running (PID:16081)."
  ok - cctrl exists on server qa.tx5.continuent.com
  ok - there is an ONLINE slave 
  ok - manager exists on server qa.tx6.continuent.com
  ok - manager status: "Tungsten Manager Service is running (PID:15056)."
  ok - cctrl exists on server qa.tx6.continuent.com
  ok - there is an ONLINE slave 
  ok - manager exists on server qa.tx8.continuent.com
  ok - manager status: "Tungsten Manager Service is running (PID:13541)."
  ok - cctrl exists on server qa.tx8.continuent.com
  ok - there is an ONLINE slave 
  ok - manager exists on server qa.tx4.continuent.com
  ok - manager status: "Tungsten Manager Service is running (PID:5421)."
  ok - cctrl exists on server qa.tx4.continuent.com
  ok - there is an ONLINE relay 
  ok - manager exists on server qa.tx7.continuent.com
  ok - manager status: "Tungsten Manager Service is running (PID:14153)."
  ok - cctrl exists on server qa.tx7.continuent.com
  ok - there is an ONLINE relay 
  ok - server qa.tx1.continuent.com - smartscale as expected: false
  ok - server qa.tx2.continuent.com - smartscale as expected: false
  ok - server qa.tx3.continuent.com - smartscale as expected: false
  ok - server qa.tx4.continuent.com - smartscale as expected: false
  ok - server qa.tx5.continuent.com - smartscale as expected: false
  ok - server qa.tx6.continuent.com - smartscale as expected: false
  ok - server qa.tx7.continuent.com - smartscale as expected: false
  ok - server qa.tx8.continuent.com - smartscale as expected: false
  ok - europe is the composite master
  ok - america is a composite slave
  ok - asia is a composite slave
  # (america) switch 
  ok - SWITCH to qa.tx8.continuent.com was successful 
  ok - SWITCH to qa.tx7.continuent.com was successful 
  # (america) failover 
  ok - qa.tx7.continuent.com failed over to qa.tx8.continuent.com
  # (america) recovery 
  ok - recovery of qa.tx7.continuent.com was successful 
  ok - SWITCH to qa.tx7.continuent.com was successful 
  # (asia) switch 
  ok - SWITCH to qa.tx5.continuent.com was successful 
  ok - SWITCH to qa.tx4.continuent.com was successful 
  # (asia) failover 
  ok - qa.tx4.continuent.com failed over to qa.tx5.continuent.com
  # (asia) recovery 
  ok - recovery of qa.tx4.continuent.com was successful 
  ok - SWITCH to qa.tx4.continuent.com was successful 
  # (europe) switch 
  ok - SWITCH to qa.tx2.continuent.com was successful 
  ok - SWITCH to qa.tx1.continuent.com was successful 
  # (europe) failover 
  ok - qa.tx1.continuent.com failed over to qa.tx2.continuent.com
  # (europe) recovery 
  ok - recovery of qa.tx1.continuent.com was successful 
  ok - SWITCH to qa.tx1.continuent.com was successful 
  # composite switch 
  ok - composite switch to america was successful
  ok - america is the composite master
  ok - asia is a composite slave
  ok - europe is a composite slave
  ok - composite switch to europe was successful
  ok - europe is the composite master
  ok - america is a composite slave
  ok - asia is a composite slave
  # composite failover 
  ok - composite failover to america was successful
  # composite recovery 
  ok - composite recovery of europe was successful
  ok - europe is now a composite online slave
  ok - qa.tx1.continuent.com is now online (relay)
  ok - manual recovery of qa.tx2.continuent.com succeeded
  ok - qa.tx2.continuent.com is now online (slave)
  ok - manual recovery of qa.tx3.continuent.com succeeded
  ok - qa.tx3.continuent.com is now online (slave)
  ok - composite switch to europe was successful
  ok - europe is the composite master
  ok - america is a composite slave
  ok - asia is a composite slave
  
=head2 Uninstall

The uninstall procedure (invoked with C<--uninstall-cluster> does the same as C<tpm uninstall> wuth two main differences:

=over 3

=item *

It will run the uninstall commands in parallel on all hosts.

=item *

It will detect if a MySQL server is not running, and restart it

=back

=head1 Debugging and reporting issues

The TCH tests whether a Tungsten cluster can perform its basic features. When one test fails we want to see where the problem was, and possibly be able to repeat the coomand manually for further examination.

The default mode for test running is silent. When all tests succeed, this is just what we want to see.

If we foresee that the tests may fail, or if we have repeated a test run to observe the reason for the failure, we have several options:

=head2 debug on screen

If you enable the option C<--debug=1>, you will simply get a dump of the internal options.

To see what commands are executed and their output prior to the test evaluation, you can use C<--debug=3>

 #i ssh -q qa.tx1.continuent.com "if [ -x /opt/continuent/cookbook_test/tungsten/tungsten-manager/bin/manager ] ; then echo OK ; else echo no; fi"
 #o << OK
 >>
 ok - manager exists on server qa.tx1.continuent.com
 #i ssh -q qa.tx1.continuent.com "/opt/continuent/cookbook_test/tungsten/tungsten-manager/bin/manager status"
 #o << Tungsten Manager Service is running (PID:8488).
 >>
 ok - manager status: "Tungsten Manager Service is running (PID:8488)."

In the above listing:

=over 3

=item *
C<#i> 

indicates the input command.

=item *
C<#o> 

shows the output, again starting with "<<" and ending with ">>".

=item *
C<ok> or C<not ok> 
 
is the result of the evaluation, i.e. if the output was what the test expected. This is the line that you normally see without the debug.

=back

Another example:

 #i ssh -q qa.tx1.continuent.com "echo ls qa.tx1.continuent.com | /opt/continuent/cookbook_test/tungsten/tungsten-manager/bin/cctrl"
 #o << Tungsten Enterprise 1.5.1 build 8
 connect to 'europe@TX1'
 europe: session established
 [LOGICAL] /europe > ls qa.tx1.continuent.com
 
 COORDINATOR[qa.tx1.continuent.com:AUTOMATIC:ONLINE]
 
 ROUTERS:
 +----------------------------------------------------------------------------+
 |connector@qa.tx1.continuent.com[9668](ONLINE, created=3, active=0)          |
 |connector@qa.tx2.continuent.com[19163](ONLINE, created=3, active=0)         |
 |connector@qa.tx3.continuent.com[6989](ONLINE, created=3, active=0)          |
 |connector@qa.tx8.continuent.com[21426](ONLINE, created=3, active=0)         |
 +----------------------------------------------------------------------------+
 
 DATASOURCES:
 +----------------------------------------------------------------------------+
 |qa.tx1.continuent.com(master:ONLINE, progress=26, THL latency=0.773)        |
 |STATUS [OK] [2012/07/09 11:20:56 AM CEST]                                   |
 +----------------------------------------------------------------------------+
 |  MANAGER(state=ONLINE)                                                     |
 |  REPLICATOR(role=master, state=ONLINE)                                     |
 |  DATASERVER(state=ONLINE)                                                  |
 |  CONNECTIONS(created=12, active=0)                                         |
 +----------------------------------------------------------------------------+
 
 [LOGICAL] /europe > 
 Exiting...
 >>
 ok - there is an ONLINE master 


=head2 More detail in the output

If you are trying to find the reason for an error, you may want to get more detailed output. One way of doing it is by asking cctrl to use the debug output, with the option C<--cctrl-options='-output debug'>.

For example, here is a switch with regular output:

 #i ssh -q qa.tx2.continuent.com "echo switch to qa.tx1.continuent.com | /opt/continuent/cookbook_test/tungsten/tungsten-manager/bin/cctrl"
 #o << Tungsten Enterprise 1.5.1 build 8
 connect to 'europe@TX2'
 europe: session established
 [LOGICAL] /europe > switch to qa.tx1.continuent.com
 SELECTED SLAVE: qa.tx1.continuent.com@europe
 FLUSH TRANSACTIONS ON CURRENT MASTER 'qa.tx2.continuent.com@europe'
 PUT THE NEW MASTER 'qa.tx1.continuent.com@europe' ONLINE
 PUT THE PRIOR MASTER 'qa.tx2.continuent.com@europe' ONLINE AS A SLAVE
 RECONFIGURING RELAY 'qa.tx3.continuent.com@asia' TO POINT TO NEW MASTER 'qa.tx1.continuent.com@europe'
 SWITCH TO 'qa.tx1.continuent.com@europe' WAS SUCCESSFUL
 [LOGICAL] /europe > 
 Exiting...
 >>
 ok - SWITCH to qa.tx1.continuent.com was successful 

And here is the same switch with debug items:

 #i ssh -q qa.tx2.continuent.com "echo switch to qa.tx1.continuent.com | /opt/continuent/cookbook_test/tungsten/tungsten-manager/bin/cctrl  -output debug "
 #o << Tungsten Enterprise 1.5.1 build 8
 connect to 'europe@TX2'
 europe: session established
 [LOGICAL] /europe > switch to qa.tx1.continuent.com
 DISABLING SENDING OF ROUTER NOTIFICATIONS
 SKIPPED qa.tx1.continuent.com@europe AS A PRIMARY BECAUSE ROLE slave != relay | master
 IDENTIFIED qa.tx2.continuent.com@europe AS A PRIMARY
 SELECTED SLAVE: qa.tx1.continuent.com@europe
 SET POLICY MAINTENANCE
 SETTING DATASOURCE 'qa.tx2.continuent.com@europe' TO 'OFFLINE'
 DEBUG: IDENTIFIED europe@world AS A PRIMARY
 Propagating transition to OFFLINE for 'qa.tx2.continuent.com@europe' to composite data source 'europe@world'
 composite data source 'europe@world' is now OFFLINE
 DataSource 'qa.tx2.continuent.com@europe' is now OFFLINE
 SETTING DATASOURCE 'qa.tx1.continuent.com@europe' TO 'OFFLINE'
 DataSource 'qa.tx1.continuent.com@europe' is now OFFLINE
 FLUSH TRANSACTIONS ON CURRENT MASTER 'qa.tx2.continuent.com@europe'
 WAIT FOR SEQUENCE NUMBER '31' ON NEW MASTER 'qa.tx1.continuent.com@europe'
 DEBUG: WAITFOR SEQNO 31 ON HOST qa.tx1.continuent.com: REQUESTED TIMEOUT MSECS: 0
 DEBUG: WAITFOR SEQNO 31 ON HOST qa.tx1.continuent.com: ACTUAL WAIT TIME: 9223370695026104367 MSECS
 DEBUG: WAITFOR SEQNO 31: ONLINE/29
 DEBUG: SLEEPING 250 MSECS
 DEBUG: WAITFOR SEQNO 31: ONLINE/31
 DEBUG: WAITFOR SEQNO 31: ONLINE/31: COMPLETE!
 WAITING FOR REPLICATOR 'qa.tx1.continuent.com' TO REACH STATE OFFLINE
 Replicator 'qa.tx1.continuent.com' is now OFFLINE
 WAITING FOR REPLICATOR 'qa.tx2.continuent.com' TO REACH STATE OFFLINE
 Replicator 'qa.tx2.continuent.com' is now OFFLINE
 Datasource 'qa.tx2.continuent.com' now has role 'slave'
 Datasource 'qa.tx1.continuent.com' now has role 'master'
 Replicator 'qa.tx1.continuent.com' now has role 'master'
 Replicator 'qa.tx2.continuent.com' is now a slave of replicator 'qa.tx1.continuent.com'
 WAITING FOR REPLICATOR 'qa.tx1.continuent.com' TO REACH STATE ONLINE
 Replicator 'qa.tx1.continuent.com' is now ONLINE
 PUT THE NEW MASTER 'qa.tx1.continuent.com@europe' ONLINE
 DEBUG: IDENTIFIED europe@world AS A PRIMARY
 Propagating transition to ONLINE for 'qa.tx1.continuent.com@europe' to composite data source 'europe@world'
 DEBUG: PROPAGATING ONLINE OF 'europe@world' TO PHYSICAL SERVICE 'europe'
 DEBUG: PROPAGATING ONLINE OF 'europe@world' TO PHYSICAL SERVICE 'asia'
 composite data source 'europe@world' is now ONLINE
 Setting server for data source 'qa.tx1.continuent.com' to READ/WRITE
 +----------------------------------------------------------------------------+
 |qa.tx1.continuent.com                                                       |
 +----------------------------------------------------------------------------+
 |Variable_name  Value                                                        |
 |read_only  OFF                                                              |
 +----------------------------------------------------------------------------+
 DataSource 'qa.tx1.continuent.com@europe' is now ONLINE
 WAITING FOR REPLICATOR 'qa.tx2.continuent.com' TO REACH STATE ONLINE
 Replicator 'qa.tx2.continuent.com' is now ONLINE
 PUT THE PRIOR MASTER 'qa.tx2.continuent.com@europe' ONLINE AS A SLAVE
 Setting server for data source 'qa.tx2.continuent.com' to READ-ONLY
 +----------------------------------------------------------------------------+
 |qa.tx2.continuent.com                                                       |
 +----------------------------------------------------------------------------+
 |Variable_name  Value                                                        |
 |read_only  ON                                                               |
 +----------------------------------------------------------------------------+
 DataSource 'qa.tx2.continuent.com@europe' is now ONLINE
 MAINTENANCE
 RECONFIGURING RELAY 'qa.tx3.continuent.com@asia' TO POINT TO NEW MASTER 'qa.tx1.continuent.com@europe'
 Replicator 'qa.tx3.continuent.com' is now a 'relay' of replicator 'qa.tx1.continuent.com'
 Replicator 'qa.tx3.continuent.com' is now ONLINE
 AUTOMATIC
 ENABLING SENDING OF ROUTER NOTIFICATIONS
 SET POLICY AUTOMATIC
 SWITCH TO 'qa.tx1.continuent.com@europe' WAS SUCCESSFUL
 [LOGICAL] /europe > 
 Exiting...
 DEBUG: CLOSING DIRECTORY FOR SESSION 'europe'
 DEBUG: CLOSING CLUSTER MANAGER INSTANCE FOR SESSION 'europe'
 DEBUG: CLOSING JMX CONNECTION FOR SESSION 'europe'
 >>
 ok - SWITCH to qa.tx1.continuent.com was successful 

=head2 Logging

Whatever you can see on the screen with C<--debug=3> is also available in a log file. If you use the option C<--log>, you will see on screen only the regular test, and the gory details will be recorded in 'tungsten-cookbook.log'.

If you want to use a different log file name, you can set it using C<--log-file=filename>

For example:

  ./cookbook/tungsten-cookbook --verbose --skip-install --run-test \
    --tests=all --log --log=file=/tmp/abraxas.log sor


=head2 Reporting issues

When you realize that you have found a bug, you want to report it. Either --debug=3 or the log file will give you a satisfactory output to write a bug report. 

Most likely, though, you will also need the log files for some or all the hosts involved. The TCH can do that for you:

  ./cookbook/tungsten-cookbook --collect-logs sor
  Logs collected in TC2012_07_09_12_20_05.tar.gz

The logs are brought from all the servers, saved in a directory named TC+current date and time, and then stored into a compressed file.

You can specify some additional detail about this logs:

=over 3

=item * 
C<--logs-store-dir=directory-name> This option allows you to define where you want to store the logs. By default, they will go to the current directory.

=item * 
C<--logs-store-name=file-name>. If the default name for the logs is not useful to you, you can indicate a different one with this option.

=item * 
C<--logs-s3-bucket=bucket-name>. If you have access to a S3 bucket, and you also have the proper credentials in the current host, you can ask the TCH to send the logs to s3 for further storage, This option requires that you have the C<aws> utility available in your path.

=back


Here's an example of one of these tarballs:

 $ tar -tzf  TC2012_07_07_14_21_43.tar.gz 
 TC2012_07_07_14_21_43/
 TC2012_07_07_14_21_43/qa_tx2_continuent_com/
 TC2012_07_07_14_21_43/qa_tx2_continuent_com/tungsten.cfg
 TC2012_07_07_14_21_43/qa_tx2_continuent_com/connector.log
 TC2012_07_07_14_21_43/qa_tx2_continuent_com/trepsvc.log
 TC2012_07_07_14_21_43/qa_tx2_continuent_com/tmsvc.log
 TC2012_07_07_14_21_43/qa_tx1_continuent_com/
 TC2012_07_07_14_21_43/qa_tx1_continuent_com/tungsten.cfg
 TC2012_07_07_14_21_43/qa_tx1_continuent_com/connector.log
 TC2012_07_07_14_21_43/qa_tx1_continuent_com/trepsvc.log
 TC2012_07_07_14_21_43/qa_tx1_continuent_com/tmsvc.log
 TC2012_07_07_14_21_43/qa_tx4_continuent_com/
 TC2012_07_07_14_21_43/qa_tx4_continuent_com/tungsten.cfg
 TC2012_07_07_14_21_43/qa_tx4_continuent_com/connector.log
 TC2012_07_07_14_21_43/qa_tx4_continuent_com/trepsvc.log
 TC2012_07_07_14_21_43/qa_tx4_continuent_com/tmsvc.log
 TC2012_07_07_14_21_43/qa_tx8_continuent_com/
 TC2012_07_07_14_21_43/qa_tx8_continuent_com/tungsten.cfg
 TC2012_07_07_14_21_43/qa_tx8_continuent_com/connector.log
 TC2012_07_07_14_21_43/qa_tx8_continuent_com/trepsvc.log
 TC2012_07_07_14_21_43/qa_tx8_continuent_com/tmsvc.log
 TC2012_07_07_14_21_43/qa_tx7_continuent_com/
 TC2012_07_07_14_21_43/qa_tx7_continuent_com/tungsten.cfg
 TC2012_07_07_14_21_43/qa_tx7_continuent_com/connector.log
 TC2012_07_07_14_21_43/qa_tx7_continuent_com/trepsvc.log
 TC2012_07_07_14_21_43/qa_tx7_continuent_com/tmsvc.log
 TC2012_07_07_14_21_43/qa_tx6_continuent_com/
 TC2012_07_07_14_21_43/qa_tx6_continuent_com/tungsten.cfg
 TC2012_07_07_14_21_43/qa_tx6_continuent_com/connector.log
 TC2012_07_07_14_21_43/qa_tx6_continuent_com/trepsvc.log
 TC2012_07_07_14_21_43/qa_tx6_continuent_com/tmsvc.log
 TC2012_07_07_14_21_43/qa_tx5_continuent_com/
 TC2012_07_07_14_21_43/qa_tx5_continuent_com/tungsten.cfg
 TC2012_07_07_14_21_43/qa_tx5_continuent_com/connector.log
 TC2012_07_07_14_21_43/qa_tx5_continuent_com/trepsvc.log
 TC2012_07_07_14_21_43/qa_tx5_continuent_com/tmsvc.log
 TC2012_07_07_14_21_43/qa_tx3_continuent_com/
 TC2012_07_07_14_21_43/qa_tx3_continuent_com/tungsten.cfg
 TC2012_07_07_14_21_43/qa_tx3_continuent_com/connector.log
 TC2012_07_07_14_21_43/qa_tx3_continuent_com/trepsvc.log
 TC2012_07_07_14_21_43/qa_tx3_continuent_com/tmsvc.log


=head1 COPYRIGHT

Copyright Continuent, Inc, 2012.

=head1 AUTHOR

Written by Giuseppe Maxia, for Continuent, Inc.

